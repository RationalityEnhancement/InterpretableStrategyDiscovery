// Generated by CoffeeScript 2.2.2
  // coffeelint: disable=max_line_length, indentation
var  STRATEGY_DESCRIPTION, INSTRUCTIONS, FLOWCHART, BLOCKS, CONDITION,CONDITION_TYPE, CONSTANT_DELAY, DEBUG, DEMO, DEMO_TRIALS, N_TRIAL, PARAMS, SCORE, SHOW_PARTICIPANT, STRUCTURE, TALK, TRAIN_TRIALS, TEST_TRIALS, calculateBonus, createStartButton, getTrials, initializeExperiment, psiturk, saveData, with_feedback, with_info, with_reward,
  modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

DEBUG = false;

TALK = false;
SHOW_PARTICIPANT = false;

if (DEBUG) {
  console.log("X X X X X X X X X X X X X X X X X\n X X X X X DEBUG  MODE X X X X X\nX X X X X X X X X X X X X X X X X");
  CONDITION = 0;
} else {
  console.log("# =============================== #\n# ========= NORMAL MODE ========= #\n# =============================== #");
}

if (mode === "{{ mode }}") {
  DEMO = true;
  CONDITION = 0;
}


// condition variables
CONDITION = parseInt(condition);
CONDITION = parseInt(window.prompt('0: Flowchart, 1: Instruction', 0));
DEBUG = window.prompt('skip to testing trials? ,0/1', 0) == 1;


if(CONDITION == 0) {
  CONDITION_TYPE = 'flowchart';
  FLOWCHART = {'div': "<img src='static/images/test_parts/DT_constant_colorcode.png' class='flowchart-image'>",
  'checks': [['p.isUnobserved.call(this, s, false)', 'p.onLevel.call(this, s, true, 3)', 'p.onItsPathIs.call(this, s, true, 10)', 'p.onBestPath.call(this, s, false)'], ['p.isUnobserved.call(this, s, false)', 'p.onLevel.call(this, s, false, 3)', 'p.onItsPathIs.call(this, s, false, 10)'], ['p.alwaysFalse.call(this,s,false)']]};

} else if(CONDITION == 1) {
  CONDITION_TYPE = 'instructions1';

  STRATEGY_DESCRIPTION = 'Click any node that contains green and orange until you find a +10. Then click the nodes that contain blue and pink.';

  INSTRUCTIONS = {'div': "<div class='instructions'>Click the nodes that contain <b>green and orange</b> until you find a +10. <br><br>Then click the nodes that contain <b>blue and pink</b>.",
  'checks': [['p.isUnobserved.call(this, s, false)', 'p.onLevel.call(this, s, true, 3)', 'p.onItsPathIs.call(this, s, true, 10)', 'p.onBestPath.call(this, s, false)'], ['p.isUnobserved.call(this, s, false)', 'p.onLevel.call(this, s, false, 3)', 'p.onItsPathIs.call(this, s, false, 10)'], ['p.alwaysFalse.call(this,s,false)']]};

} else {
  CONDITION_TYPE = 'demo';
}

PAY_BASE = '$1';
PAY_MEAN = '$2.5';

with_info = false;
with_reward = false;
with_feedback = false;

BLOCKS = void 0;

PARAMS = void 0;

TRAIN_TRIALS = void 0;
TEST_TRIALS = void 0;

DEMO_TRIALS = void 0;

STRUCTURE = void 0;

N_TRIAL = void 0;

SCORE = 0;

calculateBonus = void 0;

getTrainTrials = void 0;
getTestTrials = void 0;

CONSTANT_DELAY = 3;

psiturk = new PsiTurk(uniqueId, adServerLoc, mode);

psiturk.recordUnstructuredData('condition', CONDITION);
psiturk.recordUnstructuredData('condition_type', CONDITION_TYPE);

//psiturk.recordUnstructuredData 'with_feedback', with_feedback
psiturk.recordUnstructuredData('with_reward', with_reward);

psiturk.recordUnstructuredData('with_info', with_info);

saveData = function() {
  return new Promise(function(resolve, reject) {
    var timeout;
    timeout = delay(10000, function() {
      return reject('timeout');
    });
    return psiturk.saveData({
      error: function() {
        clearTimeout(timeout);
        console.log('Error saving data!');
        return reject('error');
      },
      success: function() {
        clearTimeout(timeout);
        console.log('Data saved to psiturk server.');
        return resolve();
      }
    });
  });
};

$(window).resize(function() {
  return checkWindowSize(1000, 600, $('#jspsych-target'));
});

$(window).resize();

$(window).on('load', function() {
  console.log("On load start");
  var loadTimeout, slowLoad;
  psiturk.preloadImages(['static/images/monkey.png', 'static/images/tree-glossary-noroot.png', 'static/images/tree-glossary-path.png', 'static/images/procedural-flowchart.png', 'static/images/practice_parts/pick.png', 'static/images/practice_parts/q1.png',  'static/images/practice_parts/click2.png','static/images/practice_parts/dont_click2.png','static/images/solution-practice.png', 'static/images/test_parts/pick.png','static/images/test_parts/q1.png','static/images/test_parts/q2.png', 'static/images/test_parts/q3.png', 'static/images/test_parts/click2.png', 'static/images/test_parts/dont_click2.png']);
  // Load data and test connection to server.
  slowLoad = function() {
    var ref;
    return (ref = $('slow-load')) != null ? ref.show() : void 0;
  };
  loadTimeout = delay(12000, slowLoad);
  return delay(300, function() {
    var id;
    console.log('Loading data');
    PARAMS = {
      inspectCost: 1,
      startTime: Date(Date.now()),
      bonusRate: .002,
      // variance: ['2_4_24', '24_4_2'][CONDITION]
      branching: '312',
      with_feedback: with_feedback,
      condition: CONDITION,
      with_reward: with_reward,
      with_info: with_info
    };
    psiturk.recordUnstructuredData('params', PARAMS);
    if (PARAMS.variance) {
      id = `${PARAMS.branching}_${PARAMS.variance}`;
    } else {
      id = `${PARAMS.branching}`;
    }
    STRUCTURE = loadJson("static/json/julian.json");
    TRAIN_TRIALS = loadJson("static/json/practice_trial.json");
    console.log(`loaded ${(TRAIN_TRIALS != null ? TRAIN_TRIALS.length : void 0)} train trials`);
    TEST_TRIALS = loadJson("static/json/test_trials.json");
    console.log(`loaded ${(TEST_TRIALS != null ? TEST_TRIALS.length : void 0)} test trials`);
    getTrainTrials = (function() {
      var idx, t;
      t = _.shuffle(TRAIN_TRIALS);
      idx = 0;
      return function(n) {
        idx += n;
        return t.slice(idx - n, idx);
      };
    })();
    getTestTrials = (function() {
      var idx, t;
      t = _.shuffle(TEST_TRIALS);
      idx = 0;
      return function(n) {
        idx += n;
        return t.slice(idx - n, idx);
      };
    })();
    if (DEBUG || TALK) {
      createStartButton();
      return clearTimeout(loadTimeout);
    } else {
      console.log('Testing saveData');
      if (DEMO) {
        clearTimeout(loadTimeout);
        return delay(500, createStartButton);
      } else {
        return saveData().then(function() {
          clearTimeout(loadTimeout);
          return delay(500, createStartButton);
        }).catch(function() {
          clearTimeout(loadTimeout);
          return $('#data-error').show();
        });
      }
    }
  });
});

createStartButton = function() {
  if (DEBUG || TALK) {
    initializeExperiment();
    return;
  }

  //f create start button manually to increase speed
  $('#jspsych-target').append("<div class='alert alert-info'>\n   To start the experiment click <b>Begin</b> below.\n</div>\n<div class='center'>\n  <button class='btn btn-primary btn-lg centered' id=\"Begin\">Begin</button>\n</div>");
  $('#Begin').click(function() {
    return initializeExperiment();
  });

  $('#load-icon').hide();
  $('#slow-load').hide();
  $('#success-load').hide();
  //return $('#load-btn').click(initializeExperiment);
};

/*
createStartButton = function() {
  if (DEBUG || TALK) {
    initializeExperiment();
    return;
  }
  //f TODO: check if its ok???
  if (false) {
    $('#jspsych-target').append("<div class='alert alert-info'>\n  <h3>Demo mode</h3>\n\n  To go through the task as if you were a participant,\n  click <b>Begin</b> above.<br>\n  To view replays of the participants\n  in our study, click <b>View Replays</b> below.\n</div>\n<div class='center'>\n  <button class='btn btn-primary btn-lg centered' id=\"view-replays\">View Replays</button>\n</div>");
    $('#view-replays').click(function() {
      SHOW_PARTICIPANT = true;
      DEMO_TRIALS = _.shuffle(loadJson("static/json/demo/312.json"));
      return initializeExperiment();
    });
  }
  $('#load-icon').hide();
  $('#slow-load').hide();
  $('#success-load').show();
  return $('#load-btn').click(initializeExperiment);
};

*/
initializeExperiment = function() {
  var Block, ButtonBlock, MouselabBlock, QuizLoop, TextBlock, bonus_text, divider, divider_intro_training, divider_pretest_training, divider_training_test, experiment_timeline, extra_question_options, extra_questions, extra_questions_answers, extra_questions_required, finish, fullMessage, img, instruct_loop, instruction_pages, instructions, nodeValuesDescription, post_test, prompt_resubmit, quiz, reprompt, reset_score, save_data, survey, talk_demo, test_block_intro, text, train_basic1, training, verbal_responses;
  $('#jspsych-target').html('');
  console.log('INITIALIZE EXPERIMENT');
  //  ======================== #
  //  ========= TEXT ========= #
  //  ======================== #

  // These functions will be executed by the jspsych plugin that
  // they are passed to. String interpolation will use the values
  // of global variables defined in this file at the time the function
  // is called.
  text = {
    debug: function() {
      if (DEBUG) {
        return "`DEBUG`";
      } else {
        return '';
      }
    }
  };
  // ================================= #
  // ========= BLOCK CLASSES ========= #
  // ================================= #
  Block = class Block {
    constructor(config) {
      _.extend(this, config);
      this._block = this; // allows trial to access its containing block for tracking state
      if (this._init != null) {
        this._init();
      }
    }

  };
  TextBlock = (function() {
    class TextBlock extends Block {};

    TextBlock.prototype.type = 'text';

    TextBlock.prototype.cont_key = [];

    return TextBlock;

  }).call(this);
  ButtonBlock = (function() {
    class ButtonBlock extends Block {};

    ButtonBlock.prototype.type = 'button-response';

    ButtonBlock.prototype.is_html = true;

    ButtonBlock.prototype.choices = ['Continue'];

    ButtonBlock.prototype.button_html = '<button class="btn btn-primary btn-lg">%choice%</button>';

    return ButtonBlock;

  }).call(this);
  QuizLoop = class QuizLoop extends Block {
    loop_function(data) {
      var c, i, len, ref;
      console.log('data', data);
      ref = data[data.length].correct;
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        if (!c) {
          return true;
        }
      }
      return false;
    }

  };
  MouselabBlock = (function() {
    class MouselabBlock extends Block {
      _init() {
        _.extend(this, STRUCTURE);
        return this.trialCount = 0;
      }

    };

    MouselabBlock.prototype.type = 'mouselab-mdp';

    MouselabBlock.prototype.playerImage = 'static/images/monkey.png';

    // moveDelay: PARAMS.moveDelay
    // clickDelay: PARAMS.clickDelay
    // moveEnergy: PARAMS.moveEnergy
    // clickEnergy: PARAMS.clickEnergy
    MouselabBlock.prototype.lowerMessage = "<b>Clicking on a node reveals its value for a $1 fee.<br>\nMove with the arrow keys.</b>";

    return MouselabBlock;

  }).call(this);

  //  ============================== #
  //  ========= HELPER ========= #
  //  ============================== #
  img = function(name, width, c ='display') {
    return `<img class='${c}' style=\"width:${width}%; height:auto\" src='static/images/${name}.png'/>`;
  };
  gif = function(name, width, c ='display') {
    return `<img class='${c}' style=\"width:${width}%; height:auto\" src='static/images/${name}.gif'/>`;
  };  //  ============================== #
  //  ========= EXPERIMENT TIMELINE ========= #
  //  ============================== #



  // MOUSELAB INSTRCUTION BLOCK --------------------------------

  instructions_0 = new Block({
    type: 'instructions',
    show_clickable_nav: true,
    pages: function()
    { return [markdown("\n\n<h1>Structure of the HIT</h1>\n\n This experiment has two phases: \n\n- **Instructions:** In this phase, you will be introduced to the experiment and given instructions about it. \n\n- **Testing:** In this phase, you will apply the knowledge acquired in the instructions phase and perform the experimental task.\n\nIf you complete the HIT, you will receive a base pay of " +PAY_BASE+ " and a bonus which is dependent on your performance in the test phase. On average, a person who conscientiously follows the instructions receives " +PAY_MEAN+ ".\n\n Click **Next** to start the **Instructions** part.")]
    }
  });

  instructions_definitions = new Block({
    type: 'instructions',
    show_clickable_nav: true,
    pages: function()
    { return [
    markdown("<h1>Background</h1>\n\n You're name is Spark, a human space traveler whose starship crashed and is now stranded on an outer-galaxy planet. The only species living on that planet are hostile robots of type R32 who act antagonistic towards all living creatures different than themselves. In order to survive, you had to pretend to be an R32. Despite your initial success, however, the robots got suspicious. They now challenge you to take the ultimate passcode test which, as they believe, can only be solved by a true member of the R32 race. Luckily, you found instructions that describe precisely how R32 behave in that test and how to pass it. Are you capable of following the instructions and tricking R32s?"),

    markdown("<h1>Passcode Test</h1>In the passcode test, you will be shown a graph, seen in the image below, that resembles a tree. The colorful circles in the tree, which R32 call nodes, hide numbers that might be revealed by clicking on them. Each click causes the colors to change. The goal of the test is to click the nodes in a particular style that depends on the coloring of the tree and the uncovered values." + img('example1', 40))];
    }
  });

  quiz1 = new Block({
  preamble: function() {
    return markdown("# Attention Check\n\nPlease answer the following questions.\n");
  },
  type: 'survey-multi-choice',
  questions: ["What is a passcode test?",
              "What is a node?",
              "How often does the coloring of the tree change?"],
  options: [['A test of R32s that checks if you are one of them.', "A test administered by psychiartists in the early 1950s.", 'This is the passcode test.'],
            ['Every circle in the tree.', "The circle at the bottom of the tree.", 'An arrow that connects two circles of the tree.'],
            ['Once.', 'With every click.', 'Never.'],
            ],
  correct: ['A test of R32s that checks if you are one of them.', 'Every circle in the tree.', 'With every click.']
});

  instructions_loop = new Block({
    timeline: [instructions_definitions, quiz1],
    loop_function: function(data) {
      var c, i, len, ref;
      console.log(data);
      ref = data[data.length-1].correct;
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        if (!c) {
          alert("You got at least one question wrong. We'll send you back to the\ninstructions and then you can try again.");
          return true; // try again
        }
      }
      psiturk.saveData();
      return false;
    }
  });


 // INSTRUCTIONS INTRO BLOCK ----------------------
 instructions_instr = new Block({
   type: 'instructions',
   show_clickable_nav: true,
   pages: function(){
     return [markdown("<h1>Instructions</h1> The description of the strategy that R32s use in the passcode test is conveyed as a sequence of instructions. The instructions tell you what to click step by step. Look at the image below to see how a sequence of instructions can look like." + img('example-instr',60)),

     markdown("<h1>Task procedure</h1> \nTo enact the strategy conveyed by the instructions do the following: \n1. Read the instructions carefully. \n2. Click the nodes by following the procedure described in the instructions. \n3. Once there are no more nodes the instructions allow clicking, click Next to advance to the next trial."),

     markdown("<h1>Your Task</h1>  In order to trick R32s that you are one of them, you will need to take the passcode test and behave exactly how the instructions you found tell you to. You start the test having 200 space dollars, just in case. If you make a mistake in the test, an R32 that is guarding you during the test needs to be bribed, and you lose 20 space dollars. For each space dollar you have left after the test block, we pay you 1 cent in bonus.")]
   }
 });

  quiz2_instr = new Block({
    preamble: function() {
      return markdown("# Attention Check \n\nPlease answer the following questions.\n");
    },
    type: 'survey-multi-choice',
    questions: ["What is your task in the game?",
                "When should you click Next?",
                "How will your bonus be determined ?"],
    options: [['Click nodes that I would like to inspect.', 'Click nodes according to the strategy described in the instructions.', 'There is no task'],
              ['When none of the nodes can be clicked according to the strategy.', 'After I clicked one node.', 'After I clicked all nodes.'],
             ['I will receive $2 bonus in any case.', 'For each correct click I will receive 5 space dollars.', 'For each space dollar I have left at the end, I will receive 1 cent in bonus.']
       ],
    correct: ['Click nodes according to the strategy described in the instructions.','When none of the nodes can be clicked according to the strategy.','For each space dollar I have left at the end, I will receive 1 cent in bonus.']
  });

  instructions_loop2_instr = new Block({
    timeline: [instructions_instr, quiz2_instr],
    loop_function: function(data) {
      var c, i, len, ref;
      ref = data[data.length-1].correct;
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        if (!c) {
          alert("You got at least one question wrong. We'll send you back to the\ninstructions and then you can try again.");
          return true; // try again
        }
      }
      psiturk.finishInstructions();
      psiturk.saveData();
      return false;
    }
  });


  // condition flowchart -----
  instructions_flow = new Block({
    type: 'instructions',
    show_clickable_nav: true,
    pages: function(){
      return [markdown("<h1>Flowchart</h1> The description of the strategy that R32s use in the passcode test takes form of a flowchart. It walks you through a list of one or more questions that you need to answer to by looking at the tree, and describes which nodes to click. Look at the image below to see how a flowchart can look like." + img('example-flow',60)),

      markdown("<h1>Task procedure</h1> \n1. Read the flowchart carefully. \n2. Think of a node you would like to click \n3. Go through the flowchart and answer questions about that node. \n4. Click that node if the flowchart landed you in a 'Click it' decision. Otherwise, think of a different node. \n5. Once you are sure that you clicked all the nodes the flowchart allows clicking -- that is it would evaluate to 'Don't click it' for every node -- click Next to advance to the next trial."),

      markdown("<h1>Your Task</h1>  In order to trick R32s that you are one of them, you will need to take the passcode test and behave exactly how the flowchart you found tells you to. You start the test having 200 space dollars, just in case. If you make a mistake in the test, an R32 that is guarding you during the test needs to be bribed, and you lose 20 space dollars. For each space dollar you have left after the test block, we pay you 1 cent in bonus.")]
    }
  });

  quiz2_flow = new Block({
    preamble: function() {
      return markdown("# Attention Check \n\nPlease answer the following questions.\n");
    },
    type: 'survey-multi-choice',
    questions: ["What is your task in the game?",
                "When should you click Next?",
                "How will your bonus be determined ?"],
    options: [['Click nodes that I would like to inspect.', 'Click nodes according to the strategy described in the flowchart.', 'There is no task'],
              ['When none of the nodes can be clicked according to the strategy.', 'After I clicked one node.', 'After I clicked all nodes.'],
             ['I will receive $2 bonus in any case.', 'For each correct click I will receive 5 space dollars.', 'For each space dollar I have left at the end, I will receive 1 cent in bonus.']
       ],
    correct: ['Click nodes according to the strategy described in the flowchart.','When none of the nodes can be clicked according to the strategy.','For each space dollar I have left at the end, I will receive 1 cent in bonus.']
  });

  instructions_loop2_flow = new Block({
    timeline: [instructions_flow, quiz2_flow],
    loop_function: function(data) {
      var c, i, len, ref;
      ref = data[data.length-1].correct;
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        if (!c) {
          alert("You got at least one question wrong. We'll send you back to the\ninstructions and then you can try again.");
          return true; // try again
        }
      }
      psiturk.finishInstructions();
      psiturk.saveData();
      return false;
    }
  });

  // practice BLOCK
  practice_intro_instr = new Block({
     type: 'instructions',
     show_clickable_nav: true,
     pages: function(){
       return [
       markdown("<h1>Practice</h1> Before you begin the real passcode test, practice how to click according to the instructions in the training trials.")];
     }
   });
 practice_instr = new MouselabBlock({
   rightMessage: "",
   showMoneyMade: false,
   show_path_rewards: false,
   lowerMessage: "<b>Click the nodes according to the strategy conveyed by the instruction! </b>",
   minTime: DEBUG ? 1 : 1,
   postTrialDelay: true || DEBUG ? 1 : 1,
   clickDelay: 0,
   show_feedback: false,
   divTutor_config: {'div': "<div class='instructions'>Click nodes that contain orange.</div>", 'checks': [['p.onBestPath.call(this,s,false)', 'p.isUnobserved.call(this,s,false)'], ['p.alwaysFalse.call(this,s,false)']], 'show_feedback': true, 'force_click_all_correct_nodes': true},
   show_div_tutor: true,
   show_custom_feedback: false,
   show_pre_select: false,
   blockName: 'practice',
   blockTitle: 'Practice trial',
   stateDisplay: 'click',
   stateClickCost: PARAMS.inspectCost,
   timeline:  getTrainTrials(1),
 });
 practice_block_instr = new Block({
   timeline: [practice_intro_instr, practice_instr]
 });

  // flowchart
  practice_intro_flow = new Block({
    type: 'instructions',
    show_clickable_nav: true,
    pages: function(){
      return [
        markdown("<h1>Practice</h1> Before you begin the real passcode test, practice how to click according to the flowchart in the training trials.")];
      }
    });
    practice_flow = new MouselabBlock({
      rightMessage: "",
      showMoneyMade: false,
      show_path_rewards: false,
      lowerMessage: "<b>Click the nodes according to the strategy conveyed by the flowchart! </b>",
      minTime: DEBUG ? 1 : 1,
      postTrialDelay: true || DEBUG ? 1 : 1,
      clickDelay: 0,
      show_feedback: false,
      divTutor_config: {'div': "<img src='static/images/practice_parts/DT_practice_colorcode.png' style='height: 150px; width: 280px; left: 100px; top: 50px; left: 120px;'></img>", 'checks': [['p.onBestPath.call(this,s,false)', 'p.isUnobserved.call(this,s,false)'], ['p.alwaysFalse.call(this,s,false)']], 'show_feedback': true, 'force_click_all_correct_nodes': true},
      show_div_tutor: true,
      show_custom_feedback: false,
      show_pre_select: false,
      blockName: 'practice',
      blockTitle: 'Practice trial',
      stateDisplay: 'click',
      stateClickCost: PARAMS.inspectCost,
      timeline:  getTrainTrials(1),
    });
    practice_block_flow = new Block({
      timeline: [practice_intro_flow, practice_flow]
    });



  // TESTING BLOCK --------------------------------
  inter_block = new Block({
    type: 'instructions',
    show_clickable_nav: true,
    pages: function(){
      return [markdown("<h1> Please click the button to continue </h1></div>")];
    }
  });

  testing_intro_instr = new Block({
    type: 'instructions',
    show_clickable_nav: true,
    pages: function(){
      SCORE = 0;
      return [markdown("<h1> Ulimate Passcode Test </h1>\n\n You are ready to begin the test block. From now on there's no feedback anymore. In the next ten rounds you shall trick the R32 robots into thinking you're one of them. To pass the test, you will have to follow the instructions that describe a general strategy of clicking. The more times you execute the strategy according to the instructions, the higher your bonus in the end! \n\n Click Next to start the Test. Good luck Spark!")];
    }
  });

  testing_instr = new MouselabBlock({
    rightMessage: "",
    showMoneyMade: false,
    show_path_rewards: false,
    lowerMessage: "<b>Click the nodes according to the strategy conveyed by the instruction! </b> <p> If you click incorrectly, you'll lose 20 cents from your bonus.</p>",
    minTime: DEBUG ? 1 : 10,
    postTrialDelay: DEBUG ? 1 : 2,
    clickDelay: 0,
    show_feedback: false,
    divTutor_config: INSTRUCTIONS,
    show_div_tutor: true,
    show_custom_feedback: false,
    show_pre_select: false,
    blockTitle: 'Passcode Test',
    blockName: 'testing',
    stateDisplay: 'click',
    stateClickCost: PARAMS.inspectCost,
    timeline:  getTestTrials(10),
    startScore: 50
  });

    testing_block_instr = new Block({
      timeline: [testing_intro_instr, testing_instr, inter_block]
    });

  // condition flowchart -----
  testing_intro_flow = new Block({
    type: 'instructions',
    show_clickable_nav: true,
    pages: function(){
      SCORE = 0;
      return [markdown("<h1> Ulimate Passcode Test </h1>\n\n You are ready to begin the test block. From now on there's no feedback anymore. In the next ten rounds you shall trick the R32 robots into thinking you're one of them. To pass the test, you will have to follow the flowchart that describes a general strategy of clicking. The more times you execute the strategy according to the flowchart, the higher your bonus in the end! \n\n Click Next to start the Test. Good luck Spark!")];
    }
  });

  testing_flow = new MouselabBlock({
      rightMessage: "",
      showMoneyMade: false,
      show_path_rewards: false,
      show_div_tutor: true,
      divTutor_config: FLOWCHART,
      show_pre_select: false,
      lowerMessage: "<b>Click the nodes according to the strategy conveyed by the flowchart! </b> <p> If you click incorrectly, you'll lose 20 cents from your bonus.</p>",
      minTime: DEBUG ? 1 : 10,
      postTrialDelay: DEBUG ? 1 : 2,
      clickDelay: 0,
      show_feedback: false,
      show_custom_feedback: false,
      blockName: 'testing',
      blockTitle: 'Passcode Test',
      stateDisplay: 'click',
      stateClickCost: PARAMS.inspectCost,
      timeline:  getTestTrials(10),
      startScore: 50
    });

    testing_block_flow = new Block({
      timeline: [testing_intro_flow, testing_flow, inter_block]
    });



  // END BLOCK --------------------------------

  /*
  final_survey = new Block({
    type: 'survey-text',
    preamble: function() {
      return markdown("# Please, answer the following questions:\n    ");
    },
    questions: ['Did you understand the strategy that the flowchart was conveying?', 'How would you describe the strategy conveyed by the flowchart to a friend?', 'What is your age?', 'Which gender do you identify with?'],
    button: 'Next'
  });
  */

  likert_survey = new Block({
    preamble: function() {
      return markdown("# Questionnaire\n\n Please indicate how much you agree with the following statements:");
    },
    type: 'survey-multi-choice',
    questions: ["The instructions about where to click were clear.", "The instructions about where to click were easy to follow.", "I completely understand the strategy that I was asked to follow."],
    options: [['1 = strongly disagree', '2 = disagree', '3 = somewhat disagree', '4 = neutral', '5 = somewhat agree', '6 = agree', '7 = strongly agree'],['1 = strongly disagree', '2 = disagree', '3 = somewhat disagree', '4 = neutral', '5 = somewhat agree', '6 = agree', '7 = strongly agree'],['1 = strongly disagree', '2 = disagree', '3 = somewhat disagree', '4 = neutral', '5 = somewhat agree', '6 = agree', '7 = strongly agree']],
    bold: true,
    button: 'Next'
  });

  strategy_quiz = new Block({
    preamble: function() {
      return markdown("# Questionnaire\n\n Please answer the following questions:");
    },
    type: 'survey-multi-choice',
    questions: ["The strategy taught to you can be best described by: ", "Which nodes were you asked to click first ?", "When did the strategy allow clicking nodes on level 3 ?"],

    options: [['1. Click any node that lies on the best path until you encounter a +10. Then click all the nodes that are connected to the +10.', '2. Click any node on level 1 or 2 until you encounter a +10 or all those nodes are clicked. Then click both nodes on level 3 that are connected to the +10.', '3. Click any node until you encounter a +10. Then click all the nodes on its path.', '4. ' + STRATEGY_DESCRIPTION] ,

    ['1. Nodes on the best path.', '2. Any nodes on level 1 or 2.', '3. Nodes on level 1 or 2 that were on the best paths.', '4. Nodes on level 3 that were on the best paths.'],

    ['1. From the beginning.', '2. After observing a +10.', '3. After there were just 2 best paths, both ending in neighbouring nodes on level 3.', '4. After clicking all the nodes on levels 1 and 2.']

  ],
    bold: true,
    button: 'Next'
  });

  final_survey_instr = new Block({
    type: 'survey-text',
    preamble: function() {
      return markdown("# Please, answer the following questions:\n    ");
    },
    questions: ["Please, describe the strategy of clicking that the instructions conveyed in your own words", "Was there anything confusing in the instructions you were following in the passcode test?", "Would you say anything differently in the instructions you were following in the passcode test?", 'What is your age?', 'Which gender do you identify with?'],
    button: 'Next'
  });

  finish = new Block({
    type: 'survey-text',
    preamble: function() {
      return markdown(`# You've completed the HIT\n\n Feel free to give us feedback below before you submit the HIT.\n\n You'll be awarded a bonus based on your performance in 24 hours after the end of the experiment. \n\n Thank you for participating! Hope you enjoyed! \n\n **VERY IMPORTANT: Please click on the "Complete HIT" button that appears on your dashboard after you finish the HIT here.**`);
    },
    questions: ['Any comments/feedback?'],
    button: 'Finish HIT'
  });

  end_block_instr = new Block({
    timeline: [final_survey_instr, finish]
  });


  // control -----------
  final_survey_flow = new Block({
    type: 'survey-text',
    preamble: function() {
      return markdown("# Please, answer the following questions:\n    ");
    },
    questions: ["Please, describe the strategy of clicking that the flowchart conveyed in your own words", "Was there anything confusing in the flowchart you were following in the passcode test?", "Would you say anything differently in the flowchart you were following in the passcode test?", 'What is your age?', 'Which gender do you identify with?'],
    button: 'Next'
  });

  end_block_flow = new Block({
    timeline: [final_survey_flow, finish]
  });


  experiment_timeline = (function() {
    if(DEBUG && CONDITION == 0){
      return [testing_flow];
    } else if(DEBUG){
      return [testing_instr];
    }

    if(CONDITION == 0){
      console.log(" -- Flowchart timeline");
      return [instructions_0, instructions_loop, instructions_loop2_flow, practice_block_flow, testing_block_flow, end_block_flow];
    } else if (CONDITION == 1) {
      console.log("-- Experimental timeline");
      return [instructions_0, instructions_loop, instructions_loop2_instr, practice_block_instr, testing_block_instr, end_block_instr];
    } else {
      console.log(" -- Demo timeline");
      return [end_block];
    }
  })();

  flatten_timeline = function(timeline){
    var global_timeline = [];

    for(var i in timeline){
      t = timeline[i];

      if(t.timeline !== undefined){
        //recursive for sub timelines
        global_timeline.push( flatten_timeline( t.timeline ));
      } else {
        // its a real block
        if(t.type !== undefined){
          info = t.type;

          if(t.questions !== undefined){
            info = info + ' : ' + t.questions.toString();
          }
          global_timeline.push( info);

        } else if (t.trial_id !== undefined){
          global_timeline.push( 'Mouselab : ' + t.trial_id)
        }
      }
    }
    global_timeline = [global_timeline.flat(1)];
    return( global_timeline  );
  }
  psiturk.recordUnstructuredData('global_timeline', JSON.stringify(flatten_timeline(experiment_timeline)) );
  //console.log( JSON.stringify(flatten_timeline(experiment_timeline)) );


  // ================================================ #
  // ========= START AND END THE EXPERIMENT ========= #
  // ================================================ #

  // bonus is the total score multiplied by something
  calculateBonus = function() {
    var bonus;
    bonus = SCORE * PARAMS.bonusRate;
    bonus = (Math.round(bonus * 100)) / 100; // round to nearest cent
    return Math.max(0, bonus);
  };
  reprompt = null;
  save_data = function() {
    return psiturk.saveData({
      success: function() {
        console.log('Data saved to psiturk server.');
        if (reprompt != null) {
          window.clearInterval(reprompt);
        }
        //return psiturk.computeBonus('compute_bonus', psiturk.completeHIT);
        psiturk.completeHIT();
      },
      error: function() {
        return prompt_resubmit;
      }
    });
  };
  prompt_resubmit = function() {
    $('#jspsych-target').html("<h1>Oops!</h1>\n<p>\nSomething went wrong submitting your HIT.\nThis might happen if you lose your internet connection.\nPress the button to resubmit.\n</p>\n<button id=\"resubmit\">Resubmit</button>");
    return $('#resubmit').click(function() {
      $('#jspsych-target').html('Trying to resubmit...');
      reprompt = window.setTimeout(prompt_resubmit, 10000);
      return save_data();
    });
  };
  return jsPsych.init({
    display_element: $('#jspsych-target'),
    timeline: experiment_timeline,
    // show_progress_bar: true
    on_finish: function() {
      if (DEBUG) {
        jsPsych.data.displayData();
        return save_data();
      } else {
        // psiturk.recordUnstructuredData('final_bonus', calculateBonus());
        return save_data();
      }
    },
    on_data_update: function(data) {
      console.log('data', data);
      return psiturk.recordTrialData(data);
    }
  });
};

// 'Best' paths are paths that guarantee the highest total reward. When nothing is observed, all the paths give reward 0 and all are 'best'
