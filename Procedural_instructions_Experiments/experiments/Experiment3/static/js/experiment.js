// Generated by CoffeeScript 2.2.2
// coffeelint: disable=max_line_length, indentation
var  BONUS, STRATEGY_DESCRIPTION, INSTRUCTIONS, FLOWCHART, BLOCKS, CONDITION,CONDITION_TYPE, CONSTANT_DELAY, DEBUG, DEMO, DEMO_TRIALS, N_TRIAL, PARAMS, SCORE, SHOW_PARTICIPANT, STRUCTURE, TALK, TRAIN_TRIALS, TEST_TRIALS, calculateBonus, createStartButton, getTrials, initializeExperiment, psiturk, saveData, with_feedback, with_info, with_reward,
modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

BONUS = 0;
DEBUG = false;
TALK = false;
SHOW_PARTICIPANT = false;

if (DEBUG) {
  console.log("X X X X X X X X X X X X X X X X X\n X X X X X DEBUG  MODE X X X X X\nX X X X X X X X X X X X X X X X X");
} else {
  console.log("# =============================== #\n# ========= NORMAL MODE ========= #\n# =============================== #");
}

// condition variables
CONDITION = parseInt(condition);
//CONDITION = parseInt(window.prompt('0: No-training, 1: training, 2: training-instructions', 0));
//DEBUG = window.prompt('skip to testing trials? ,0/1', 0) == 1;

if(CONDITION == 0) {
  CONDITION_TYPE = 'no-training';

} else if(CONDITION == 1){
  CONDITION_TYPE = 'Training';

} else {
  CONDITION_TYPE = 'demo';
}

PAY_BASE = '$1.5';
PAY_MEAN = '$3';

with_info = false;
with_reward = false;
with_feedback = false;

BLOCKS = void 0;

PARAMS = void 0;

TRAIN_TRIALS = void 0;
TEST_TRIALS = void 0;

DEMO_TRIALS = void 0;

STRUCTURE = void 0;

N_TRIAL = void 0;

SCORE = 0;

calculateBonus = void 0;

getTrainTrials = void 0;
getTestTrials = void 0;

CONSTANT_DELAY = 3;

psiturk = new PsiTurk(uniqueId, adServerLoc, mode);

psiturk.recordUnstructuredData('condition', CONDITION);
psiturk.recordUnstructuredData('condition_type', CONDITION_TYPE);

//psiturk.recordUnstructuredData 'with_feedback', with_feedback
psiturk.recordUnstructuredData('with_reward', with_reward);

psiturk.recordUnstructuredData('with_info', with_info);

saveData = function() {
  return new Promise(function(resolve, reject) {
    var timeout;
    timeout = delay(10000, function() {
      return reject('timeout');
    });
    return psiturk.saveData({
      error: function() {
        clearTimeout(timeout);
        console.log('Error saving data!');
        return resolve();
        return reject('error');
      },
      success: function() {
        clearTimeout(timeout);
        console.log('Data saved to psiturk server.');
        return resolve();
      }
    });
  });
};

$(window).resize(function() {
  return checkWindowSize(1000, 600, $('#jspsych-target'));
});

$(window).resize();

$(window).on('load', function() {
  console.log("On load start");
  var loadTimeout, slowLoad;
  psiturk.preloadImages(['static/images/FlightPlanningPartiallyRevealed.png', 'static/images/NodeInspector.png', 'static/images/training_parts/flowchart_training.png', 'static/images/roadtrip/maps/fantasy_map_1560976725599.png', 'static/images/roadtrip/maps/fantasy_map_1560976804519.png', 'static/images/roadtrip/maps/fantasy_map_1560976821363.png', 'static/images/roadtrip/maps/fantasy_map_1560976821363.png', 'static/images/roadtrip/maps/fantasy_map_1560976853546.png', 'static/images/roadtrip/maps/fantasy_map_1560976890783.png']);
  //psiturk.preloadVideos(['static/videos/growthMindset.mp4']);

  // Load data and test connection to server.
  slowLoad = function() {
    var ref;
    return (ref = $('slow-load')) != null ? ref.show() : void 0;
  };
  loadTimeout = delay(12000, slowLoad);
  return delay(300, function() {
    var id;
    console.log('Loading data');
    PARAMS = {
      inspectCost: 1,
      startTime: Date(Date.now()),
      bonusRate: .002,
      // variance: ['2_4_24', '24_4_2'][CONDITION]
      branching: '312',
      with_feedback: with_feedback,
      condition: CONDITION,
      with_reward: with_reward,
      with_info: with_info
    };
    psiturk.recordUnstructuredData('params', PARAMS);
    if (PARAMS.variance) {
      id = `${PARAMS.branching}_${PARAMS.variance}`;
    } else {
      id = `${PARAMS.branching}`;
    }
    STRUCTURE = loadJson("static/json/structure/tree.json");
    TRAIN_TRIALS = loadJson("static/json/train_trials.json");
    console.log(`loaded ${(TRAIN_TRIALS != null ? TRAIN_TRIALS.length : void 0)} train trials`);
    TEST_TRIALS = loadJson("static/json/roadtrip_trials.json");
    console.log(`loaded ${(TEST_TRIALS != null ? TEST_TRIALS.length : void 0)} test trials`);
    getTrainTrials = (function() {
      var idx, t;
      t = _.shuffle(TRAIN_TRIALS);
      idx = 0;
      return function(n){
        idx += n;
        return t.slice(idx - n, idx);
      };
    })();
    getTestTrials = (function() {
      var idx, t;
      t = _.shuffle(TEST_TRIALS);
      idx = 0;
      return function(n) {
        idx += n;
        return t.slice(idx - n, idx);
      };
    })();
    if (DEBUG || TALK) {
      createStartButton();
      return clearTimeout(loadTimeout);
    } else {
      console.log('Testing saveData');
      if (DEMO) {
        clearTimeout(loadTimeout);
        return delay(500, createStartButton);
      } else {
        return saveData().then(function() {
          clearTimeout(loadTimeout);
          return delay(500, createStartButton);
        }).catch(function() {
          clearTimeout(loadTimeout);
          return $('#data-error').show();
        });
      }
    }
  });
});

createStartButton = function() {
  if (DEBUG || TALK) {
    initializeExperiment();
    return;
  }

  //f create start button manually to increase speed
  $('#jspsych-target').append("<div class='alert alert-info'>\n   To start the experiment click <b>Begin</b> below.\n</div>\n<div class='center'>\n  <button class='btn btn-primary btn-lg centered' id=\"Begin\">Begin</button>\n</div>");
  $('#Begin').click(function() {
    return initializeExperiment();
  });

  $('#load-icon').hide();
  $('#slow-load').hide();
  $('#success-load').hide();
  //return $('#load-btn').click(initializeExperiment);
};

initializeExperiment = function() {
  var Block, ButtonBlock, MouselabBlock, QuizLoop, TextBlock, bonus_text, divider, divider_intro_training, divider_pretest_training, divider_training_test, experiment_timeline, extra_question_options, extra_questions, extra_questions_answers, extra_questions_required, finish, fullMessage, img, instruct_loop, instruction_pages, instructions, nodeValuesDescription, post_test, prompt_resubmit, quiz, reprompt, reset_score, save_data, survey, talk_demo, test_block_intro, text, train_basic1, training, verbal_responses;
  $('#jspsych-target').html('');
  console.log('INITIALIZE EXPERIMENT');
  //  ======================== #
  //  ========= TEXT ========= #
  //  ======================== #

  // These functions will be executed by the jspsych plugin that
  // they are passed to. String interpolation will use the values
  // of global variables defined in this file at the time the function
  // is called.
  text = {
    debug: function() {
      if (DEBUG) {
        return "`DEBUG`";
      } else {
        return '';
      }
    }
  };
  // ================================= #
  // ========= BLOCK CLASSES ========= #
  // ================================= #
  Block = class Block {
    constructor(config) {
      _.extend(this, config);
      this._block = this; // allows trial to access its containing block for tracking state
      if (this._init != null) {
        this._init();
      }
    }

  };
  TextBlock = (function() {
    class TextBlock extends Block {};

    TextBlock.prototype.type = 'text';

    TextBlock.prototype.cont_key = [];

    return TextBlock;

  }).call(this);
  ButtonBlock = (function() {
    class ButtonBlock extends Block {};

    ButtonBlock.prototype.type = 'button-response';

    ButtonBlock.prototype.is_html = true;

    ButtonBlock.prototype.choices = ['Continue'];

    ButtonBlock.prototype.button_html = '<button class="btn btn-primary btn-lg">%choice%</button>';

    return ButtonBlock;

  }).call(this);
  QuizLoop = class QuizLoop extends Block {
    loop_function(data) {
      var c, i, len, ref;
      console.log('data', data);
      ref = data[data.length].correct;
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        if (!c) {
          return true;
        }
      }
      return false;
    }

  };
  MouselabBlock = (function() {
    class MouselabBlock extends Block {
      _init() {
        _.extend(this, STRUCTURE);
        return this.trialCount = 0;
      }

    };

    MouselabBlock.prototype.type = 'mouselab-mdp';
    MouselabBlock.prototype.playerImage = 'static/images/plane.png';
    MouselabBlock.prototype.lowerMessage = "<b>Clicking on a node reveals its value for a $1 fee.<br>\nMove with the arrow keys.</b>";

    return MouselabBlock;

  }).call(this);

  //  ============================== #
  //  ========= HELPER ========= #
  //  ============================== #
  img = function(name, width, c ='display') {
    return `<img class='${c}' style=\"width:${width}%; height:auto\" src='static/images/${name}.png'/>`;
  };
  gif = function(name, width, c ='display') {
    return `<img class='${c}' style=\"width:${width}%; height:auto\" src='static/images/${name}.gif'/>`;
  };  //  ============================== #
  //  ========= EXPERIMENT TIMELINE ========= #
  //  ============================== #






  // MOUSELAB INSTRCUTION BLOCK --------------------------------

  welcome_control = new Block({
    type: 'instructions',
    show_clickable_nav: true,
    pages: function()
    { return [markdown("\n\n<h1>Structure of the HIT</h1>\n\n This experiment has two phases: \n\n- **Instructions:** In this phase, you will be introduced to the experiment and given instructions about it. \n\n- **Questionnaire:** In this phase, we ask you to answer some questions. \n\n If you complete the HIT, you will receive a base pay of " +PAY_BASE+ ".\n\n Click **Next** to start the **Instructions** part.")]
  }});

  welcome = new Block({
    type: 'instructions',
    show_clickable_nav: true,
    pages: function()
    { return [markdown("\n\n<h1>Structure of the HIT</h1>\n\n This experiment has three phases: \n\n- **Instructions:** In this phase, you will be introduced to the experiment and given instructions about it. \n\n- **Training:** In this phase, you will apply the knowledge acquired in the instructions phase. \n\n- **Questionnaire:** In this phase, we ask you to answer some questions. \n\nIf you complete the HIT, you will receive a base pay of " +PAY_BASE+ ".\n\n Click **Next** to start the **Instructions** part.")]
  }});


  transfer_intro_flight = new Block({
    type: 'instructions',
    show_clickable_nav: true,
    pages: function(){
      return [
        markdown("# Flight Planning is a metaphor for life\n\nFlight Planning is like life. You can choose your own path. Before you do, ***you can collect information about the short-term, mid-term, and long-term consequences*** of choosing one path versus another. In Flight Planning the short-term, mid-term, and long-term consequences are the money that you gain or lose at the first, second, and third destination of your trip.")]
      }
    });


  //instructions flightplanning
  instructions_flightplanning = new Block({
    type: 'instructions',
    show_clickable_nav: true,
    pages: function()
    { return [
      markdown("# Flight Planning\n\n - The *Flight Planning* game is about choosing the series of destinations that an airplane should fly to.\n - The gray circles in the screenshot below are the possible destinations the airplane can fly to.\n - ***Some destinations may be more profitable than others.***\n\n<img class='display' style=\"width:50%; height:auto\" src='static/images/FlightPlanningPartiallyRevealed.png'/>\n"),
      markdown("# Flight Planning\n\n - The airplane can ***only*** fly along the routes shown in the screenshot below and ***only*** in the direction of the arrows.\n - Therefore some destinations can only be reached via other intermediate destinations.\n - You will be able to move the airplane with the arrow keys.\n\n<img class='display' style=\"width:50%; height:auto\" src='static/images/FlightPlanningPartiallyRevealed.png'/>"),
      markdown("# Collecting information\n\n- It's hard to make good decision when you can't see the reward of a destination!\n- Fortunately, ***you can click on a destination to find out how much the airplane would gain or lose if the airplane was to fly there***.\n- The image below illustrates how this works.\n- Clicking on an airport *doesn't* mean flying there. The airplnae *won't* get the profit or loss a click reveals unless you fly there later on.\n- **Note:** you can only gather information *before* the first flight. Once the airplane starts moving clicking will be disabled.\n\n<img class='display' style=\"width:50%; height:auto\" src='static/images/NodeInspector.png'/>"),
      markdown("# Gains and losses\n- Landing the plane at an airport will either yield a reward of up to <b><font color='green'>$48</font></b> or a loss of up to <b><font color='red'>$-48</font></b>\n- Information is costly. The price for finding out how profitable different destinations are is <b>$1 per click</b>.\n- The goal of the airplane is to end up with as much money as possible at the end of the game.\n\n"),
      markdown("# Additional information\n\n<img class='display' style='width:50%; height:auto' src='static/images/NodeInspector.png'/>\n- You will play Flight Planning for multiple rounds.\n- ***Every time you play this game the profits/losses of the airports will be different.*** So you have to plan a route every time.")]
    }
  });

  //TRAINING BLOCK
  training_intro = new Block({
    type: 'instructions',
    show_clickable_nav: true,
    pages: function(){
      psiturk.finishInstructions();
      return [
        markdown("<h1>Training</h1> You can now proceed with the 10 training trials.")]
      }
    });

    training = new MouselabBlock({
      rightMessage: "",
      showMoneyMade: true,
      lowerMessage: "<b>Click destinations to reveal their value for $1! <br> When you're done clicking, move to get the most reward. </b>",
      minTime: DEBUG ? 1 : 10,
      postTrialDelay: DEBUG ? 1 : 2,
      clickDelay: 0,
      show_feedback: false,
      show_custom_feedback: false,
      blockName: 'training',
      blockTitle: 'Training',
      stateDisplay: 'click',
      stateClickCost: PARAMS.inspectCost,
      timeline:  DEBUG ? getTrainTrials(1) : getTrainTrials(10),
      startScore: 50
    });
    training_block = new Block({
      timeline: [instructions_flightplanning, training_intro, training]
    });


    instructions_instr = new Block({
      type: 'instructions',
      show_clickable_nav: true,
      pages: function(){
        return [markdown("<h1>Instructions</h1> To help you play the Flight Planning task, we will convey to you a near-optimal clicking strategy in form of instructions. The instructions tell you what to click step by step. Look at the image below to see how a sequence of instructions can look like." + img('example-instr',60)),

        markdown("<h1>Task procedure</h1> \nTo enact the strategy conveyed by the instructions do the following: \n1. Read the instructions carefully. \n2. Click the destinations by following the procedure described in the instructions. \n3. Once there are no more destinations the instructions allow clicking, start moving the airplane."),

        markdown("<h1>Your Task</h1>  Your task is to make clicks according to the instructions in order to maximize earnings for the airplane.")]
      }
    });
    training_instr = new MouselabBlock({
      rightMessage: "",
      showMoneyMade: true,
      lowerMessage: "<b>Click the destinations according to the strategy conveyed by the instructions! <br> When you're done clicking, move to get the most reward. </b>",
      show_div_tutor: true,
      divTutor_config: {'div': "<div class='instructions'>Click on the destinations representing the most long-term consequences you haven't examined yet until you find the most valuable outcome (a reward of +48).",
  'checks': [['p.isMostDistantUnobserved.call(this, s, false)', 'p.existsValue.call(this, s, true, 48)'], ['p.alwaysFalse.call(this,s,false)'], ['p.alwaysFalse.call(this,s,false)']], 'show_feedback': false},
      minTime: DEBUG ? 1 : 10,
      postTrialDelay: DEBUG ? 1 : 2,
      clickDelay: 0,
      show_feedback: false,
      show_custom_feedback: false,
      blockName: 'training',
      blockTitle: 'Training',
      stateDisplay: 'click',
      stateClickCost: PARAMS.inspectCost,
      timeline:  DEBUG ? getTrainTrials(1) : getTrainTrials(10),
      startScore: 50
    });
    training_block_instr = new Block({
      timeline: [instructions_flightplanning, instructions_instr, transfer_intro_flight, training_intro, training_instr]
    });


    // TRAINING BLOCK Control
    training_intro_control = new Block({
      type: 'instructions',
      show_clickable_nav: true,
      pages: function(){
        psiturk.finishInstructions();
        return [
          markdown("<h1>Preparation</h1> To prepare you for the upcoming task we would like you to get to know the principle of Growth Mindset. Therefore you will watch a short video on the next page. \n\n Please watch the video carefully and with audio. From time to time a button will show up. Please press that button to confirm that you're attentive. If you miss the button, the video will restart. \n\n Enjoy! ")]
        }
      });
      training_control = new Block({
        type: "button-response",
        vid_src : 'static/videos/growthMindset.mp4',
        url_source: 'https://www.youtube.com/watch?v=rUJkbWNnNy4',
        timing_stim: 5,
        number_attention_ckecks: -1,
        time_to_react: 20
      });
      training_block_control = new Block({
        timeline: [training_intro_control, training_control]
      });





      // SECOND PHASE INTSTRCUTIONS
      questionnaire_intro = new Block({
        type: 'instructions',
        show_clickable_nav: true,
        pages: function(){
          return [ markdown("<h1> Questionnaire</h1>\n\n In this block we would like you to answer some questions carefully. Each page must be considered for at least 20 seconds.")]
        }
      });

      // MORTGAGE TASK
        mortgage_task1 = new Block({
          type: 'survey-multi-choice',
          preamble: function() {
            return markdown("# Choosing a mortgage: \n Imagine that you are choosing between three mortgage loans that have\ndifferent interest rates in the first month, the remainder of the\nfirst year, and the next 19 years.");
          },

          questions: ['I would make my decision based on the interst rate in the ...'],
          options: [['first month.', 'the remainder of the first year.', 'next 19 years.']],
          required: DEBUG ? Array(1).fill(false) : Array(1).fill(true),
          bold: true,
          min_time: 10
        });

        mortgage_task2 = new Block({
          type: 'survey-text',
          preamble: function() {
            return markdown("# Choosing a mortgage: \n Imagine that you are choosing between three mortgage loans that have\ndifferent interest rates in the first month, the remainder of the\nfirst year, and the next 19 years.");
          },
          questions: ['How would you choose between these?', 'How did you decide which mortgage is best?'],
          button: 'Next',
          min_time: 20,
        });


      // PREFERENCE TASK
      preference_task1 = new Block({
        preamble: function() {
          return markdown("# Questionnaire\n\nPlease indicate for each of the following decisions, whether you would prefer the smaller payment in the near future or the bigger payment later.");
        },
        type: 'survey-multi-choice',
        questions: Array(9).fill('I prefer'),
        options: [['$10 guaranteed today', '$80 guaranteed in 3 months'], ['$20 guaranteed today', '$80 guaranteed in 3 months'], ['$30 guaranteed today', '$80 guaranteed in 3 months'], ['$40 guaranteed today', '$80 guaranteed in 3 months'], ['$50 guaranteed today', '$80 guaranteed in 3 months'], ['$60 guaranteed today', '$80 guaranteed in 3 months'], ['$65 guaranteed today', '$80 guaranteed in 3 months'], ['$70 guaranteed today', '$80 guaranteed in 3 months'], ['$75 guaranteed today', '$80 guaranteed in 3 months']].reverse(),
        required: DEBUG ? Array(9).fill(false) : Array(9).fill(true),
        bold: true,
        min_time: 20
      });

      preference_task2 = new Block({
        preamble: function() {
          return markdown("# Questionnaire\n\nPlease indicate for each of the following decisions, whether you would prefer the smaller payment in the near future or the bigger payment later.");
        },
        type: 'survey-multi-choice',
        questions: Array(10).fill('I prefer'),
        options: [['$85 guaranteed today', '$30 guaranteed in 6 months'], ['$10 guaranteed today', '$80 guaranteed in 6 months'], ['$20 guaranteed today', '$80 guaranteed in 6 months'], ['$30 guaranteed today', '$80 guaranteed in 6 months'], ['$40 guaranteed today', '$80 guaranteed in 6 months'], ['$50 guaranteed today', '$80 guaranteed in 6 months'], ['$60 guaranteed today', '$80 guaranteed in 6 months'], ['$65 guaranteed today', '$80 guaranteed in 6 months'], ['$70 guaranteed today', '$80 guaranteed in 6 months'], ['$75 guaranteed today', '$80 guaranteed in 6 months']].reverse(),
        required: DEBUG ? Array(10).fill(false) : Array(10).fill(true),
        bold: true,
        min_time: 20
      });
      preference_task3 = new Block({
        preamble: function() {
          return markdown("# Questionnaire\n\nPlease indicate for each of the following decisions, whether you would prefer the smaller payment in the near future or the bigger payment later.");
        },
        type: 'survey-multi-choice',
        questions: Array(9).fill('I prefer'),
        options: [['$10 guaranteed in 6 months', '$80 guaranteed in 9 months'], ['$20 guaranteed in 6 months', '$80 guaranteed in 9 months'], ['$30 guaranteed in 6 months', '$80 guaranteed in 9 months'], ['$40 guaranteed in 6 months', '$80 guaranteed in 9 months'], ['$50 guaranteed in 6 months', '$80 guaranteed in 9 months'], ['$60 guaranteed in 6 months', '$80 guaranteed in 9 months'], ['$65 guaranteed in 6 months', '$80 guaranteed in 9 months'], ['$70 guaranteed in 6 months', '$80 guaranteed in 9 months'], ['$75 guaranteed in 6 months', '$80 guaranteed in 9 months']].reverse(),
        required: DEBUG ? Array(9).fill(false) : Array(9).fill(true),
        bold: true,
        min_time: 20
      });
      preference_task4 = new Block({
        preamble: function() {
          return markdown("# Questionnaire\n\nPlease indicate for each of the following decisions, whether you would prefer the smaller payment in the near future or the bigger payment later.");
        },
        type: 'survey-multi-choice',
        questions: Array(10).fill('I prefer'),
        options: [['$10 guaranteed in 6 months', '$80 guaranteed in 12 months'], ['$20 guaranteed in 6 months', '$80 guaranteed in 12 months'], ['$30 guaranteed in 6 months', '$80 guaranteed in 12 months'], ['$40 guaranteed in 6 months', '$80 guaranteed in 12 months'], ['$50 guaranteed in 6 months', '$80 guaranteed in 12 months'], ['$60 guaranteed in 6 months', '$80 guaranteed in 12 months'], ['$65 guaranteed in 6 months', '$80 guaranteed in 12 months'], ['$70 guaranteed in 6 months', '$80 guaranteed in 12 months'], ['$75 guaranteed in 6 months', '$80 guaranteed in 12 months'], ['$90 guaranteed today', '$70 guaranteed in 12 months']].reverse(),
        required: DEBUG ? Array(10).fill(false) : Array(10).fill(true),
        bold: true,
        min_time: 20
      });
      preference_block = new Block({
        timeline: [preference_task1, preference_task2, preference_task3, preference_task4]
      });


      // END BLOCK
      final_survey = new Block({
        type: 'survey-text',
        preamble: function() {
          return markdown("# Please, answer the following questions:\n    ");
        },
        questions: ["Was there anything confusing in the instructions?", 'What is your age?', 'Which gender do you identify with?'],
        button: 'Next'
      });

      finish = new Block({
        type: 'survey-text',
        preamble: function() {
          return markdown(`# You've completed the HIT\n\n Feel free to give us feedback below before you submit the HIT.\n\n You'll be awarded a bonus based on your performance in 24 hours after the end of the experiment. \n\n Thank you for participating! Hope you enjoyed! \n\n **VERY IMPORTANT: Please click on the "Complete HIT" button that appears on your dashboard after you finish the HIT here.**`);
        },
        questions: ['Any comments/feedback?'],
        button: 'Finish HIT'
      });

      end_block = new Block({
        timeline: [final_survey, finish]
      });




      experiment_timeline = (function() {

        if(CONDITION == 0){
          console.log(" -- Control");
          return [welcome_control, training_block_control, questionnaire_intro, mortgage_task2, preference_block, end_block];

        } else if (CONDITION == 1) {
          console.log("-- Experimental I");
          return [welcome,  training_block_instr, questionnaire_intro, mortgage_task2, preference_block, end_block];

        } else {
          console.log(" -- Demo timeline");
          return [end_block];
        }
      })();

      flatten_timeline = function(timeline){
        var global_timeline = [];

        for(var i in timeline){
          t = timeline[i];

          if(t.timeline !== undefined){
            //recursive for sub timelines
            global_timeline.push( flatten_timeline( t.timeline ));
          } else {
            // its a real block
            if(t.type !== undefined){
              info = t.type;
              if(t.questions !== undefined){
                info = info + ' : ' + t.questions.toString();
              }
              global_timeline.push( info);

            } else if (t.trial_id !== undefined){
              global_timeline.push('Mouselab : ' + t.trial_id);

            } else if(t.start_city !== undefined){
              global_timeline.push('Roadtrip : ' + t.start_city);
            }
          }
        }
        global_timeline = [global_timeline.flat(1)];
        return( global_timeline  );
      }
      psiturk.recordUnstructuredData('global_timeline', JSON.stringify(flatten_timeline(experiment_timeline)) );
      //console.log( JSON.stringify(flatten_timeline(experiment_timeline)) );


      // ================================================ #
      // ========= START AND END THE EXPERIMENT ========= #
      // ================================================ #

      // bonus is the total score multiplied by something
      calculateBonus = function() {
        var bonus;
        bonus = SCORE * PARAMS.bonusRate;
        bonus = (Math.round(bonus * 100)) / 100; // round to nearest cent
        return Math.max(0, bonus);
      };
      reprompt = null;
      save_data = function() {
        return psiturk.saveData({
          success: function() {
            console.log('Data saved to psiturk server.');
            if (reprompt != null) {
              window.clearInterval(reprompt);
            }
            //return psiturk.computeBonus('compute_bonus', psiturk.completeHIT);
            psiturk.completeHIT();
          },
          error: function() {
            return prompt_resubmit;
          }
        });
      };
      prompt_resubmit = function() {
        $('#jspsych-target').html("<h1>Oops!</h1>\n<p>\nSomething went wrong submitting your HIT.\nThis might happen if you lose your internet connection.\nPress the button to resubmit.\n</p>\n<button id=\"resubmit\">Resubmit</button>");
        return $('#resubmit').click(function() {
          $('#jspsych-target').html('Trying to resubmit...');
          reprompt = window.setTimeout(prompt_resubmit, 10000);
          return save_data();
        });
      };
      return jsPsych.init({
        display_element: $('#jspsych-target'),
        timeline: experiment_timeline,
        // show_progress_bar: true
        on_finish: function() {
          jsPsych.data.displayData();
          if (DEBUG) {
            jsPsych.data.displayData();
            return save_data();
          } else {
            psiturk.recordUnstructuredData('final_bonus', BONUS);
            return save_data();
          }
        },
        on_data_update: function(data) {
          console.log('data', data);
          return psiturk.recordTrialData(data);
        }
      });
    };

    // 'Best' paths are paths that guarantee the highest total reward. When nothing is observed, all the paths give reward 0 and all are 'best'
