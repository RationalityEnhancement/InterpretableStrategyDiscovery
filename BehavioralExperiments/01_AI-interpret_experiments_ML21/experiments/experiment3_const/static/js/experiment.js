// Generated by CoffeeScript 2.2.2
  // coffeelint: disable=max_line_length, indentation
var  BLOCKS, CONDITION,CONDITION_TYPE, CONSTANT_DELAY, DEBUG, DEMO, DEMO_TRIALS, N_TRIAL, PARAMS, SCORE, SHOW_PARTICIPANT, STRUCTURE, TALK, TRAIN_TRIALS, TEST_TRIALS, calculateBonus, createStartButton, getTrials, initializeExperiment, psiturk, saveData, with_feedback, with_info, with_reward,
  modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

DEBUG = false;

TALK = false;

SHOW_PARTICIPANT = false;

if (DEBUG) {
  console.log("X X X X X X X X X X X X X X X X X\n X X X X X DEBUG  MODE X X X X X\nX X X X X X X X X X X X X X X X X");
  CONDITION = 0;
} else {
  console.log("# =============================== #\n# ========= NORMAL MODE ========= #\n# =============================== #");
}

if (mode === "{{ mode }}") {
  DEMO = true;
  CONDITION = 0;
}


// condition variables
CONDITION = parseInt(condition);
//CONDITION = window.prompt('cond 0 exp/1 control', 0);
//DEBUG = window.prompt('DEBUG 0/1', 0) == 1;

if(CONDITION == 0) {
  CONDITION_TYPE = 'experimental';
} else if(CONDITION == 1)
{
  CONDITION_TYPE = 'control';
}
else
{
  CONDITION_TYPE = 'demo';
}

PAY_BASE = '$3';
PAY_MEAN = '$6.5';

with_info = false;

with_reward = false;

//f with_feedback = with_reward || with_info;
with_feedback = false;

BLOCKS = void 0;

PARAMS = void 0;

TRAIN_TRIALS = void 0;
TEST_TRIALS = void 0;

DEMO_TRIALS = void 0;

STRUCTURE = void 0;

N_TRIAL = void 0;

SCORE = 0;

calculateBonus = void 0;

getTrainTrials = void 0;
getTestTrials = void 0;

CONSTANT_DELAY = 3;

psiturk = new PsiTurk(uniqueId, adServerLoc, mode);

psiturk.recordUnstructuredData('condition', CONDITION);
psiturk.recordUnstructuredData('condition_type', CONDITION_TYPE);

//psiturk.recordUnstructuredData 'with_feedback', with_feedback
psiturk.recordUnstructuredData('with_reward', with_reward);

psiturk.recordUnstructuredData('with_info', with_info);

saveData = function() {
  return new Promise(function(resolve, reject) {
    var timeout;
    timeout = delay(10000, function() {
      return reject('timeout');
    });
    return psiturk.saveData({
      error: function() {
        clearTimeout(timeout);
        console.log('Error saving data!');
        return reject('error');
      },
      success: function() {
        clearTimeout(timeout);
        console.log('Data saved to psiturk server.');
        return resolve();
      }
    });
  });
};

$(window).resize(function() {
  return checkWindowSize(1000, 600, $('#jspsych-target'));
});

$(window).resize();

$(window).on('load', function() {
  console.log("On load start");
  var loadTimeout, slowLoad;
  psiturk.preloadImages(['static/images/tree-of-cash-unrevealed.png', 'static/images/tree-of-cash.png' , 'static/images/DT_constant3_train2.png', 'static/images/tree-glossary-noroot.png', 'static/images/tree-glossary-path.png', 'static/images/tree-glossary-path2.png', 'static/images/training_phase_example.png','static/images/train_tree_parts_quiz/blank.png','static/images/train_tree_parts_quiz/rect1.png','static/images/train_tree_parts_quiz/rect2.png','static/images/train_tree_parts_quiz/rect3.png']);
  // Load data and test connection to server.
  slowLoad = function() {
    var ref;
    return (ref = $('slow-load')) != null ? ref.show() : void 0;
  };
  loadTimeout = delay(12000, slowLoad);
  return delay(300, function() {
    var id;
    console.log('Loading data');
    PARAMS = {
      inspectCost: 1,
      startTime: Date(Date.now()),
      bonusRate: .002,
      // variance: ['2_4_24', '24_4_2'][CONDITION]
      branching: '312',
      with_feedback: with_feedback,
      condition: CONDITION,
      with_reward: with_reward,
      with_info: with_info
    };
    psiturk.recordUnstructuredData('params', PARAMS);
    if (PARAMS.variance) {
      id = `${PARAMS.branching}_${PARAMS.variance}`;
    } else {
      id = `${PARAMS.branching}`;
    }
    STRUCTURE = loadJson("static/json/julian.json");
    TRAIN_TRIALS = loadJson("static/json/train_trials.json");
    console.log(`loaded ${(TRAIN_TRIALS != null ? TRAIN_TRIALS.length : void 0)} train trials`);
    TEST_TRIALS = loadJson("static/json/test_trials.json");
    console.log(`loaded ${(TEST_TRIALS != null ? TEST_TRIALS.length : void 0)} test trials`);
    getTrainTrials = (function() {
      var idx, t;
      t = _.shuffle(TRAIN_TRIALS);
      idx = 0;
      return function(n) {
        idx += n;
        return t.slice(idx - n, idx);
      };
    })();
    getTestTrials = (function() {
      var idx, t;
      t = _.shuffle(TEST_TRIALS);
      idx = 0;
      return function(n) {
        idx += n;
        return t.slice(idx - n, idx);
      };
    })();
    if (DEBUG || TALK) {
      createStartButton();
      return clearTimeout(loadTimeout);
    } else {
      console.log('Testing saveData');
      if (DEMO) {
        clearTimeout(loadTimeout);
        return delay(500, createStartButton);
      } else {
        return saveData().then(function() {
          clearTimeout(loadTimeout);
          return delay(500, createStartButton);
        }).catch(function() {
          clearTimeout(loadTimeout);
          return $('#data-error').show();
        });
      }
    }
  });
});

createStartButton = function() {
  if (DEBUG || TALK) {
    initializeExperiment();
    return;
  }

  //f create start button manually to increase speed
  $('#jspsych-target').append("<div class='alert alert-info'>\n   To start the experiment click <b>Begin</b> below.\n</div>\n<div class='center'>\n  <button class='btn btn-primary btn-lg centered' id=\"Begin\">Begin</button>\n</div>");
  $('#Begin').click(function() {
    return initializeExperiment();
  });

  $('#load-icon').hide();
  $('#slow-load').hide();
  $('#success-load').hide();
  //return $('#load-btn').click(initializeExperiment);
};

/*
createStartButton = function() {
  if (DEBUG || TALK) {
    initializeExperiment();
    return;
  }
  //f TODO: check if its ok???
  if (false) {
    $('#jspsych-target').append("<div class='alert alert-info'>\n  <h3>Demo mode</h3>\n\n  To go through the task as if you were a participant,\n  click <b>Begin</b> above.<br>\n  To view replays of the participants\n  in our study, click <b>View Replays</b> below.\n</div>\n<div class='center'>\n  <button class='btn btn-primary btn-lg centered' id=\"view-replays\">View Replays</button>\n</div>");
    $('#view-replays').click(function() {
      SHOW_PARTICIPANT = true;
      DEMO_TRIALS = _.shuffle(loadJson("static/json/demo/312.json"));
      return initializeExperiment();
    });
  }
  $('#load-icon').hide();
  $('#slow-load').hide();
  $('#success-load').show();
  return $('#load-btn').click(initializeExperiment);
};

*/
initializeExperiment = function() {
  var Block, ButtonBlock, MouselabBlock, QuizLoop, TextBlock, bonus_text, divider, divider_intro_training, divider_pretest_training, divider_training_test, experiment_timeline, extra_question_options, extra_questions, extra_questions_answers, extra_questions_required, finish, fullMessage, img, instruct_loop, instruction_pages, instructions, nodeValuesDescription, post_test, prompt_resubmit, quiz, reprompt, reset_score, save_data, survey, talk_demo, test_block_intro, text, train_basic1, training, verbal_responses;
  $('#jspsych-target').html('');
  console.log('INITIALIZE EXPERIMENT');
  //  ======================== #
  //  ========= TEXT ========= #
  //  ======================== #

  // These functions will be executed by the jspsych plugin that
  // they are passed to. String interpolation will use the values
  // of global variables defined in this file at the time the function
  // is called.
  text = {
    debug: function() {
      if (DEBUG) {
        return "`DEBUG`";
      } else {
        return '';
      }
    }
  };
  // ================================= #
  // ========= BLOCK CLASSES ========= #
  // ================================= #
  Block = class Block {
    constructor(config) {
      _.extend(this, config);
      this._block = this; // allows trial to access its containing block for tracking state
      if (this._init != null) {
        this._init();
      }
    }

  };
  TextBlock = (function() {
    class TextBlock extends Block {};

    TextBlock.prototype.type = 'text';

    TextBlock.prototype.cont_key = [];

    return TextBlock;

  }).call(this);
  ButtonBlock = (function() {
    class ButtonBlock extends Block {};

    ButtonBlock.prototype.type = 'button-response';

    ButtonBlock.prototype.is_html = true;

    ButtonBlock.prototype.choices = ['Continue'];

    ButtonBlock.prototype.button_html = '<button class="btn btn-primary btn-lg">%choice%</button>';

    return ButtonBlock;

  }).call(this);
  QuizLoop = class QuizLoop extends Block {
    loop_function(data) {
      var c, i, len, ref;
      console.log('data', data);
      ref = data[data.length].correct;
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        if (!c) {
          return true;
        }
      }
      return false;
    }

  };
  MouselabBlock = (function() {
    class MouselabBlock extends Block {
      _init() {
        _.extend(this, STRUCTURE);
        return this.trialCount = 0;
      }

    };

    MouselabBlock.prototype.type = 'mouselab-mdp';

    MouselabBlock.prototype.playerImage = 'static/images/monkey.png';

    // moveDelay: PARAMS.moveDelay
    // clickDelay: PARAMS.clickDelay
    // moveEnergy: PARAMS.moveEnergy
    // clickEnergy: PARAMS.clickEnergy
    MouselabBlock.prototype.lowerMessage = "<b>Clicking on a node reveals its value for a $1 fee.<br>\nMove with the arrow keys.</b>";

    return MouselabBlock;

  }).call(this);



  //  ============================== #
  //  ========= HELPER ========= #
  //  ============================== #
  img = function(name) {
    return `<img class='display' src='static/images/${name}.png'/>`;
  };

  //  ============================== #
  //  ========= EXPERIMENT TIMELINE ========= #
  //  ============================== #



  // MOUSELAB INSTRCUTION BLOCK --------------------------------

  instructions_0 = new Block({
    type: 'instructions',
    show_clickable_nav: true,
    pages: function()
    {
      return [markdown("<h1>Structure of the HIT</h1>\n\n In this HIT, you will participate in a psychology experiment. This experiment has two phases: \n\n- **Instructions:** In this phase, you will be introduced to a certain game and will be given instructions on how to play it. \n\n- **Test:** In this phase, you will be tested on your ability to do well in that game.\n\nIf you complete the HIT, you will receive a base pay of " +PAY_BASE+ " and a bonus which is dependent on your performance in the test phase. On average, a person who conscientously follows the instructions receives " +PAY_MEAN+ ".\n\n Click **Next** to start the **Instructions** part.")];
    }
  });

    instructions_1 = new Block({
    type: 'instructions',
    show_clickable_nav: true,
    pages: function()
    {
      return [
	markdown("<h1>Tree of Cash </h1>\n\nIn this HIT, you will help a\n money-loving monkey to swing through a tree. When you land on a gray circle\n (a ***node***) the value revealed by the node is added to the monkey's total reward. The monkey's goal is to make that total reward **as high as possible**. \n\nYou will be able to move the monkey with the arrow keys, but only in the direction\n of the arrows between the nodes. For simplicity, arrows that go up-left and up-right are mapped to the left arrow key and the right arrow key respectively.\n\n The image below shows the tree that you will be guiding the monkey through when the game starts.\n\n<img class='display' style=\"width:50%; height:auto\" src='static/images/tree-of-cash-unrevealed.png'/>"),
	markdown("   <h1> Node Inspector</h1>\n\n It is hard to decide where to go when you don't know the rewards. Fortunately, you can use a ***node inspector*** to reveal\n the value of any node. \n\nTo use the node inspector, you have to simply **click on a node**. \n\n However, each click takes away <span style='color: red;'> **$1**  </span> from the monkey. \n\n To understand how it all works, you can look at the image below. \n\n **Note:** You can only use the node inspector when you're on the initial\n node, i.e. before you have moved.\n\n \n\n<img class='display' style=\"width:70%; height:auto\" src='static/images/tree-of-cash.png'/>")];
    }
  });

  tryout1 = new Block({
    type: 'instructions',
    show_clickable_nav: true,
    pages: function(){
      SCORE = 0;
      return [markdown("   <h1> Practice</h1>\n\n In the next round, you will be given a chance to try out the node inspector and move the monkey so that you get used to the game.\n\n**Enjoy!**\n\n</div>")];
    }
  });

  practice = new MouselabBlock({
    showMoneyMade: true,
    show_path_rewards: false,
    showRightImage: false,
    rightMessage: '\xa0'.repeat(8) + 'Score: <span id=mouselab-score/>',
    minTime: DEBUG ? 1 : 7,
    postTrialDelay: true || DEBUG ? 1 : 11,
    clickDelay: 0,
    show_feedback: with_feedback,
    blockName: 'practice',
    stateDisplay: 'click',
    stateClickCost: PARAMS.inspectCost,
    timeline: getTrainTrials(1),
    startScore: 50
  });

  instruct_mouselab = new Block({
    timeline: [instructions_0, instructions_1, tryout1, practice]
  });

  instructions_definitions = new Block({
    type: 'instructions',
    show_clickable_nav: true,
    pages: function()
    {
      return [markdown("<h1>Definitions </h1>\n\nTo advance to the next stages of the experiment, you will need to understand the following definitions: \n\n- A node that is grey and was not yet clicked is called an ***unobserved*** node. A node that was already clicked and revealed a positive or a negative reward is called an ***observed*** node. \n\n- The tree has 3 ***levels*** defined by the horizontal alignment of the nodes. \n\n- The nodes of ***higher*** levels are ***higher*** up in the tree. That is, the nodes of Level 3 are above the nodes of Level 2 and the nodes of Level 2 are above the nodes of Level 1. \n\nSee the image below to get a better sense of these notions.\n\n<img class='display' style=\"width:75%; height:auto\" src='static/images/tree-glossary-noroot.png'/>"),
	      markdown("<h1> Definitions </h1>\n Furthermore: \n\n- Each node lies on a path: a sequence of nodes from level 1 to level 3. \n- ***Best paths*** are paths where the sum of rewards add up to the highest value. The reward for unobserved nodes counts as 0.\n- In particular, if **all** the nodes are ***unobserved*** then **each** path is a ***best*** path. \n\n- In general, a path with reward 0 or a negative reward can also be best. Whether a path is best depends on how it compares to other paths. \n\n Examples below show cases where there is just one best path (left) or multiple best paths (right). \n\n<div style='display: flex'> <img class='display' style=\"width:50%; height:auto\" src='static/images/tree-glossary-path.png'/> <img class='display' style=\"width:50%; height:auto\" src='static/images/tree-glossary-path2.png'/>")];
    }
  });

  quiz1 = new Block({
  preamble: function() {
    return markdown("# Quiz\n\nPlease answer the following questions about the *Tree of Cash* game\n");
  },
  type: 'survey-multi-choice',
  questions: ["What is a node?",
              "What is an unobserved node?",
              "What is a best path?"],
  options: [['Every grey circle in the tree.', "The circle the monkey is currently on.", 'An arrow that connects two circles of the tree.'],
            ['Any node the monkey is currently on.', 'A node which has not been clicked in the current trial.', 'A node that has never been clicked in any of the previous trials.'],
            ['The shortest path.', 'A path with the most unobserved nodes on it.', 'A path of nodes whose rewards sum up to the highest value in comparison to other paths.'],
            ],
  required: [true, true, true],
  correct: ["Every grey circle in the tree.", 'A node which has not been clicked in the current trial.', 'A path of nodes whose rewards sum up to the highest value in comparison to other paths.']
});

  instruct_loop = new Block({
    timeline: [instructions_definitions, quiz1],
    loop_function: function(data) {
      var c, i, len, ref;
      console.log(data);
      ref = data[data.length-1].correct;
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        if (!c) {
          alert("You got at least one question wrong. We'll send you back to the\ninstructions and then you can try again.");
          return true; // try again
        }
      }
      psiturk.finishInstructions();
      psiturk.saveData();
      return false;
    }
  });


  tryout = new Block({
    type: 'instructions',
    show_clickable_nav: true,
    pages: function(){
      SCORE = 0;
      return [markdown("   <h1> Understanding the Definitions </h1>\n\n In the following rounds you will need to demonstrate that you **understand** the definitions introduced in the previous block. \n\n In each trial a node will become **highlighted** and a question mark will appear on it. To the right of the tree you will see a **question** pop up that concerns the highlighted node and uses the notions detailed before. **Answer that question** by **clicking** an appropriate button undearneath it saying **Yes** or **No**. Since the next question will be unveiled only if the given answer is correct, you'll receive **feedback** to guide you. As an additional help, above each node at the top you will see the reward the monkey can expect to get if you navigate it to that node. \n\n After answering both questions correctly, the node will be uncovered. The whole process will repeat **6 times.** \n\n \n\n **You are allowed to advance to the next stage of the experiment only if you answer every question correctly at least 75% of the time.** \n\n *Try it out on the next page!* \n")];
    }
  });

  practice2 = new MouselabBlock({
    rightMessage: "",
    leftMessage: ' ',
    showMoneyMade: false,
    show_path_rewards: true,
    show_interactive_flowchart: true,
    flowchart: { 'images': ['blank.png', 'rect1.png', 'rect2.png', 'rect3.png', 'blank.png', 'blank.png'],
                      'path': 'static/images/train_tree_parts_quiz/',
                      'mappings': [[1,1], [2,3],    [4,5],    [4,5],  [],           []],
                      'offsets': [0.3,     0.3,      0.3,      0.3,       0,           0],
                      'checks': [[], ['p.onLevel.call(flowchart, s, true, 1)', 'p.onBestPath.call(flowchart, s, false)'], ['p.isUnobserved.call(flowchart, s, false)', 'p.onBestPath.call(flowchart, s, false)', 'p.onItsBestPathIs.call(flowchart, s, true, 5)'], ['p.isUnobserved.call(flowchart, s, false)', 'p.onItsPathIs.call(flowchart, s, false, -8)']],
                      'force_correct': true,
                      'force_interaction': true,
                      'show_feedback': true,
                      'as_quiz': true,
                      'quiz_random': true,
                      'as_auto_select': true,
                      'auto_select_N': DEBUG ? 1 : 6,
                      'quiz_random_N': DEBUG ? 1 : 2
                    },
    show_pre_select: true,
    lowerMessage: "<b>Answer questions about the highlighted node by clicking the yes/no buttons</b>",
    minTime: DEBUG ? 1 : 5,
    postTrialDelay: true || DEBUG ? 1 : 11,
    clickDelay: 0,
    show_feedback: false,
    show_custom_feedback: false,
    blockName: 'practice2',
    stateDisplay: 'click',
    stateClickCost: PARAMS.inspectCost,
    timeline:  getTrainTrials(1),
    startScore: 50
  });
  //f flowchart loop variables
  var answer_stats = {
    'total': Array(practice2.flowchart.images.length-3).fill(0),
    'correct': Array(practice2.flowchart.images.length-3).fill(0),
    'round': 0
  };

  practice_loop = new Block({
    timeline: [practice2],
    loop_function: function(data){
      // params
      let max_trial_number = DEBUG ? 1 : 10;
      let min_trial_number = DEBUG ? 0 : 3;
      let min_question_number = 15;
      let comprehend_threshold = 0.75;

      // helper
      let sum = function(arr1, arr2){
        return arr1.map(function (num, idx) {return num + arr2[idx];});
      }
      let div = function(arr1, arr2){
        return arr1.map(function (num, idx) {if(arr2[idx] != 0) return num/arr2[idx]; return 0});
      }
      let last_trial = data[data.length-1].queries.flowchart.answer_stats;

      // update statistics
      answer_stats.total = sum(answer_stats.total, last_trial.total);
      answer_stats.correct = sum(answer_stats.correct, last_trial.correct);
      answer_stats.round++;

      console.log(answer_stats);

      // decide on statistics
      if(answer_stats.round < max_trial_number){
        if( Math.min(... answer_stats.total) < min_question_number || answer_stats.round < min_trial_number) return true;
        for(el of div(answer_stats.correct, answer_stats.total)){
          if(el < comprehend_threshold) return true;
        }
      }
      return false;
    }
  });

  practice_block= new Block({
    timeline: [tryout, practice_loop]
  });


  // ADDITIONAL ROUND ---------------------------------
  flowchart_instructions = new Block({
    type: 'instructions',
    show_clickable_nav: true,
    pages: function(){
      SCORE = 0;
	      return [markdown("<h1> Flowchart </h1>\n\n Now you understand the definitions and know how to answer the questions. In the next two rounds you will need to show that you can use those questions to guide you. Namely, your task will be to **follow a strategy** that uses question-answering to convey how to use the node inspector.\n- Formally, the strategy takes the form of a ***flowchart*** describing which kinds of nodes you should **click** on. \n\n- To use the flowchart, **think of a particular node**. \n\n- The flowchart walks you through a list of questions that ask something about that node (or the tree in general).\n\n- Your answers lead to a decision: <span style='color: green;'> **CLICK IT** </span> or <span style='color: red;'> **DON'T CLICK IT** </span>. \n\nTo see the flowchart you will interact with, look at the image below. \n\n<img class='display' style=\"width:50%; height:auto\" src='static/images/DT_constant3_train2.png'/>"),
		      markdown("<h1> Reading the Flowchart </h1>\n\n Even if you understand the questions, it can be overwhelming to follow the strategy by looking at the whole flowchart at once. It is easier to pick a node to be clicked, and go through the questions step by step until reaching a decision - <span style='color: green;'> **CLICK IT** </span> or <span style='color: red;'> **DON'T CLICK IT** </span> - and then acting accordingly. We made the flowchart interactive so that this kind of reasoning was possible."), markdown("<h1> Using the Flowchart </h1>\n\n The process in which you should use the flowchart to help the monkey do well is the following: \n\n- **Select a node** you would like to uncover by clicking on it -- this click is **free**. The selected node will become highlighted and a question mark will appear on it. \n\n- To the right of the tree you will see a part of the flowchart pop up. It will ask a question about the node you selected. **Answer that question** by clicking an appropriate button undearneath it saying Yes or No. \n\n- The answer will make the **next question** of the flowchart appear. Repeat the process of answering flowchart questions until a rectangle with a decision is unveiled: <span style='color: green;'>**CLICK IT**</span> or <span style='color: red;'>**DON'T CLICK IT**</span>.\n\n- If the flowchart points to <span style='color: green;'>**CLICK IT**</span>, **click the node you selected again**. If it points to <span style='color: red;'>**DON'T CLICK IT**</span>, **unselect the node by clicking a neutral background**, and select a different node. \n\n- If you tried all the nodes, and your answers led to <span style='color: red;'> **DON'T CLICK IT** </span> decision, move the monkey through the tree so as to collect as much reward as possible. To choose the monkey’s path, it is enough to only look at the rewards of the observed nodes and ignore the unobserved nodes. \n\n <div style='display: flex'> <img class='display' style=\"width:70%; height:auto\" src='static/images/training_phase_example.png'/>")];
    }
  });

  quiz2 = new Block({
    preamble: function() {
      return markdown("# Quiz\n\nPlease answer the following questions about the *Tree of Cash* game\n");
    },
    type: 'survey-multi-choice',
    questions: ["What is your task for the next two rounds?",
                "How should you make decisions about where to click?",
                "When should you start climbing the monkey up the tree?"],
    options: [['Follow a strategy of clicking in the Tree of Cash game that is conveyed by a flowchart.', 'Collect all the possible rewards in the tree.', 'Climb the monkey up the top of the tree.'],
              ['I can click randomly.', 'By answering questions and acting according to the flowchart.', 'Based on the expert demonstrations.'],
              ['After all the nodes were clicked.', "When all the nodes lead to DON'T CLICK IT decision according to the flowchart.", 'Based on a careful computation of expected rewards.' ]
	     ],
    required: [true, true, true],
    correct: ['Follow a strategy of clicking in the Tree of Cash game that is conveyed by a flowchart.', 'By answering questions and acting according to the flowchart.', "When all the nodes lead to DON'T CLICK IT decision according to the flowchart."]
  });

  instruct_loop2 = new Block({
    timeline: [flowchart_instructions, quiz2],
    loop_function: function(data) {
      var c, i, len, ref;
      console.log(data);
      ref = data[data.length-1].correct;
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        if (!c) {
          alert("You got at least one question wrong. We'll send you back to the\ninstructions and then you can try again.");
          return true; // try again
        }
      }
      psiturk.saveData();
      return false;
    }
  });

  flowchart_practice = new Block({
    type: 'instructions',
    show_clickable_nav: true,
    pages: function(){
      SCORE = 0;
      return [markdown("   <h1> Practice </h1>\n\n In the next two rounds you will use the node inspector according to the flowchart that was shown in the previous stage. After selecting a node, you will need to go through it and make a click only after reaching a decision. Since you know the questions it will ask, there will be no feedback on whether your answers are correct or not. You will, however, receive feedback if you do not follow the advised action -- clicking the node or not clicking it -- or when you miss to click all the allowed nodes. \n\n *Try it out on the next page.* \n")];
    }
  });

  additional_round = new MouselabBlock({
    rightMessage: "",
    leftMessage: ' ',
    showMoneyMade: true,
    show_path_rewards: true,
    show_interactive_flowchart: true,
    flowchart: { 'images': ['pick.png', 'q1.png', 'q2.png', 'q3.png', 'click2.png', 'dont_click2.png'],
                      'path': 'static/images/train_tree_parts/',
                      'mappings': [[1,1], [2,3],    [4,5],    [4,5],  [],           []],
                      'offsets': [0.5,     0.12,      0.375,   0.375,       0,           0],
                      'checks': [[], ['p.onLevel.call(flowchart, s, true, 1)', 'p.onBestPath.call(flowchart, s, false)'], ['p.isUnobserved.call(flowchart, s, false)', 'p.onBestPath.call(flowchart, s, false)', 'p.onItsBestPathIs.call(flowchart, s, true, 5)'], ['p.isUnobserved.call(flowchart, s, false)', 'p.onItsPathIs.call(flowchart, s, false, -8)']],
                      'force_correct': false,
                      'force_interaction': true,
                      'show_feedback': false,
                      'force_correct_clicking': true,
                      'force_click_all_correct_nodes': true
                    },
    show_pre_select: true,
    lowerMessage: "<b>Follow the flowchart and start moving when all nodes lead to DON'T CLICK IT.</b>",
    minTime: DEBUG ? 1 : 10,
    postTrialDelay: true || DEBUG ? 1 : 11,
    clickDelay: 0,
    show_feedback: false,
    show_custom_feedback: false,
    blockName: 'additional_round',
    stateDisplay: 'click',
    stateClickCost: PARAMS.inspectCost,
    timeline:  getTrainTrials(2),
    startScore: 50
  });

  additional_block = new Block({
    timeline: [flowchart_practice, additional_round]
  });


  // TESTING BLOCK --------------------------------
  testing_intro = new Block({
    type: 'instructions',
    show_clickable_nav: true,
    pages: function(){
      SCORE = 0;
      return [markdown("   <h1> Test Block </h1>\n\n In the next ten rounds you will use a flowchart to make clicks and swing the monkey through the tree again. **From this moment on, however, the rewards underneath the nodes will be different than before.** Because of that, so will be the flowchart. Thankfully, it will hint a nearly optimal strategy that lets the monkey to collect an average of $7 per round! Your task in the test will be to **follow that flowchart**. Similarly to the practice trials, you will be able to click the node and uncover it or click somewhere else only after the flowchart unveils to a decision.\n\n\n  \n\n  Given you will not be shown any feedback on your answers about the nodes or actions you take, think about the questions and  your actions carefully! Also, make sure you click all the allowed nodes. \n\n  Each node you **click according to the flowchart gives you 10 cents** in bonus, whereas each **incorrect click takes away 10  cents** from this bonus."), markdown(" <h1> Test Block </h1>\n\n You are about to start the test phase \n\n The minimum time required per trial is 90 seconds. The timer counts only when you attend the experiment (the web browser page). \n\n Remember! \n\n- Click a node once to highlight it and enable answering questions \n\n- Click the highlighted node again if the flowchart led you to <span style='color: green;'> **CLICK IT** </span> decision \n\n- Click somewhere else to unselect the node and let it stay unobserved. \n\n- If you tried all the nodes, and the flowchart led you to <span style='color: red;'> **DON'T CLICK IT** </span> decision everytime, it's time to swing the monkey through the tree and let it collect the largest possible reward! \n\n\n\n  *Start the test on the next page. Good luck!*")];
    }
  });


  testing = new MouselabBlock({
    rightMessage: "",
    showMoneyMade: true,
    show_path_rewards: true,
    show_interactive_flowchart: true,
    flowchart: { 'images': ['pick.png', 'q1.png', 'q2.png', 'q3.png', 'click2.png', 'dont_click2.png'],
                      'path': 'static/images/test_tree_parts/',
                      'mappings': [[1,1], [2,3],    [4,5],    [4,5],   [],           []],
                      'offsets': [0.5,     0.2,      0.375,   0.375,      0,           0],
                      'checks': [[], ['p.onLevel.call(flowchart, s, true, 3)', 'p.onBestPath.call(flowchart, s, false)'], ['p.isUnobserved.call(flowchart, s, false)', 'p.onItsBestPathIs.call(flowchart, s, true, 10)'], ['p.isUnobserved.call(flowchart, s, false)', 'p.onItsPathIs.call(flowchart, s, false, 10)']],
                      'force_interaction': true,
                    },
    confirmMessage:  "Many people overlook some of the nodes that the flowchart allows clicking and miss the bonus. Are you sure you want to move?",
    show_pre_select: true,
    lowerMessage: "<b>Please, follow the flowchart. Your bonus depends on it.<br>\n If all nodes lead to DON'T CLICK IT, move with the arrow keys.</b>",
    minTime: DEBUG ? 1 : 90,
    postTrialDelay: true || DEBUG ? 1 : 11,
    clickDelay: 0,
    show_feedback: false,
    show_custom_feedback: false,
    blockName: 'testing',
    stateDisplay: 'click',
    stateClickCost: PARAMS.inspectCost,
    timeline:  getTestTrials(10),
    startScore: 50
  });

    testing_block = new Block({
      timeline: [testing_intro, testing]
    });


  // condition 2 -----
  testing_intro_condition2 = new Block({
    type: 'instructions',
    show_clickable_nav: true,
    pages: function(){
      SCORE = 0;
      return [markdown("   <h1> Test Block </h1>\n\n In the next twenty-five rounds you will be tested how well you can play the game on your own -- without any flowchart. Moreover, **from this moment on, the rewards underneath the nodes will be different than before.** Certainly, the more you will learn about them through clicking, the easier it will be to plan. Keep in mind however, that you want the monkey to collect the largest possible reward and each click that tells you something about the values under the nodes costs $1. \n\n Remember! The higher the monkey's total reward, the larger **bonus** you will get -- for each **$1 the monkey makes, you will receive 2 cents**. \n\n The minimum time required per trial is 45 seconds. The timer counts **only** when you attend the experiment (the web browser page).\n\n *Start the test on the next page. Good luck!* \n")];
    }
  });

  testing_condition2 = new MouselabBlock({
    showMoneyMade: true,
    showRightImage: false,
    show_path_rewards: true,
    lowerMessage: '<b>Clicking on a node reveals its value for a $1 fee.<br>\nMove with the arrow keys.</b>',
    minTime: DEBUG ? 1 : 45,
    postTrialDelay: true || DEBUG ? 1 : 11,
    clickDelay: 0,
    show_feedback: with_feedback,
    blockName: 'testing',
    stateDisplay: 'click',
    stateClickCost: PARAMS.inspectCost,
    timeline:  getTestTrials(25),
    startScore: 0
  });

  testing_block_condition2 = new Block({
    timeline: [testing_intro_condition2, testing_condition2]
  });


  // END BLOCK --------------------------------
  inter_block = new Block({
    type: 'instructions',
    show_clickable_nav: true,
    pages: function(){
      return [markdown("   <h1> Please click the button to continue </h1></div>")];
    }
  });

  /*
  final_survey = new Block({
    type: 'survey-text',
    preamble: function() {
      return markdown("# Please, answer the following questions:\n    ");
    },
    questions: ['Did you understand the strategy that the flowchart was conveying?', 'How would you describe the strategy conveyed by the flowchart to a friend?', 'What is your age?', 'Which gender do you identify with?'],
    button: 'Next'
  });
  */

  final_survey = new Block({
    type: 'survey-text',
    preamble: function() {
      return markdown("# Please, answer the following questions:\n    ");
    },
    questions: ['The strategy was to click only the nodes on Level 1 or 2 which lied on a best path (you could double-check that with the path rewards displayed at the top) . Uncovering a -10, -5 or 5 changed which paths were ‘best’. That mini-strategy was valid until you encountered a +10 on Level 1 or 2. Then, you were supposed to click both the nodes on Level 3 which were connected to the +10. In most cases you terminated after that, unless the two paths that ended in the clicked nodes stopped being best. That would happen, for instance, if you uncovered +10 in your first move, and then on Level 3 you would see two -10s. That would make all the nodes on Level 1 or 2 lie on best paths with reward 0 again, and you would continue clicking. Did you grasp that strategy?', 'What was confusing about the flowchart?', 'What didn’t you understand?', 'What questions would you ask in the flowchart so that the other person understood the strategy?', 'What is your age?', 'Which gender do you identify with?'],
    button: 'Next'
  });

  final_edu_survey = new Block({
    preamble: function() {
      return markdown("You are almost done. Please answer the following questions:");
    },
    type: 'survey-multi-choice',
    questions: ["What is the highest degree or level of school you have completed?",
                "Did you have prior training in computer science?"],
    options: [ ['No schooling completed', 'High school graduate', 'College degree'],
               ['Yes', 'No']],
    button_label: 'Finish'
  });

  finish = new Block({
    type: 'survey-text',
    preamble: function() {
      return markdown(`# You've completed the HIT\n\n Feel free to give us feedback below before you submit the HIT.\n\n You'll be awarded a bonus based on your performance in 24 hours after the end of the experiment. \n\n Thank you for participating! Hope you enjoyed! \n\n **VERY IMPORTANT: Please click on the "Complete HIT" button that appears on your dashboard after you finish the HIT here.**`);
    },
    questions: ['Any comments/feedback?'],
    button: 'Finish HIT'
  });

  end_block = new Block({
    timeline: [inter_block, final_survey, final_edu_survey, finish]
  });



  // condition2 -----------
  final_survey_condition2 = new Block({
    type: 'survey-text',
    preamble: function() {
      return markdown("# Please, answer the following questions:\n    ");
    },
    questions: ['What is your age?', 'Which gender do you identify with?'],
    button: 'Next'
  });

  end_block_condition2 = new Block({
    timeline: [inter_block, final_survey_condition2, final_edu_survey, finish]
  });


  experiment_timeline = (function() {
    if(CONDITION == 0){
      console.log("-- Experimental timeline");
      return [instruct_mouselab, instruct_loop, practice_block, instruct_loop2, additional_block, testing_block, end_block];
    } else if (CONDITION == 1) {
      console.log(" -- Control timeline");
      return [instruct_mouselab, instruct_loop, practice_block, instruct_loop2, additional_block, testing_block_condition2, end_block_condition2];
    } else {
      console.log(" -- Demo timeline");
      return [practice2];
    }
  })();

  flatten_timeline = function(timeline){
    var global_timeline = [];

    for(var i in timeline){
      t = timeline[i];

      if(t.timeline !== undefined){
        //recursive for sub timelines
        global_timeline.push( flatten_timeline( t.timeline ));
      } else {
        // its a real block
        if(t.type !== undefined){
          info = t.type;

          if(t.questions !== undefined){
            info = info + ' : ' + t.questions.toString();
          }
          global_timeline.push( info);

        } else if (t.trial_id !== undefined){
          global_timeline.push( 'Mouselab : ' + t.trial_id)
        }

      }
    }
    global_timeline = [global_timeline.flat(1)];
    return( global_timeline  );
  }
  psiturk.recordUnstructuredData('global_timeline', JSON.stringify(flatten_timeline(experiment_timeline)) );
  //console.log( JSON.stringify(flatten_timeline(experiment_timeline)) );


  // ================================================ #
  // ========= START AND END THE EXPERIMENT ========= #
  // ================================================ #

  // bonus is the total score multiplied by something
  calculateBonus = function() {
    var bonus;
    bonus = SCORE * PARAMS.bonusRate;
    bonus = (Math.round(bonus * 100)) / 100; // round to nearest cent
    return Math.max(0, bonus);
  };
  reprompt = null;
  save_data = function() {
    return psiturk.saveData({
      success: function() {
        console.log('Data saved to psiturk server.');
        if (reprompt != null) {
          window.clearInterval(reprompt);
        }
        //return psiturk.computeBonus('compute_bonus', psiturk.completeHIT);
        psiturk.completeHIT();
      },
      error: function() {
        return prompt_resubmit;
      }
    });
  };
  prompt_resubmit = function() {
    $('#jspsych-target').html("<h1>Oops!</h1>\n<p>\nSomething went wrong submitting your HIT.\nThis might happen if you lose your internet connection.\nPress the button to resubmit.\n</p>\n<button id=\"resubmit\">Resubmit</button>");
    return $('#resubmit').click(function() {
      $('#jspsych-target').html('Trying to resubmit...');
      reprompt = window.setTimeout(prompt_resubmit, 10000);
      return save_data();
    });
  };
  return jsPsych.init({
    display_element: $('#jspsych-target'),
    timeline: experiment_timeline,
    // show_progress_bar: true
    on_finish: function() {
      if (DEBUG) {
        jsPsych.data.displayData();
        return save_data();
      } else {
        // psiturk.recordUnstructuredData('final_bonus', calculateBonus());
        return save_data();
      }
    },
    on_data_update: function(data) {
      console.log('data', data);
      return psiturk.recordTrialData(data);
    }
  });
};

// 'Best' paths are paths that guarantee the highest total reward. When nothing is observed, all the paths give reward 0 and all are 'best'
