// Generated by CoffeeScript 2.2.2
  // coffeelint: disable=max_line_length, indentation
var BLOCKS, CONDITION,CONDITION_TYPE, CONSTANT_DELAY, DEBUG, DEMO, DEMO_TRIALS, N_TRIAL, PARAMS, SCORE, SHOW_PARTICIPANT, STRUCTURE, TALK, TRIALS, calculateBonus, createStartButton, getTrials, initializeExperiment, psiturk, saveData, with_feedback, with_info, with_reward,
  modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

DEBUG = false;

TALK = false;

SHOW_PARTICIPANT = false;

if (DEBUG) {
  console.log("X X X X X X X X X X X X X X X X X\n X X X X X DEBUG  MODE X X X X X\nX X X X X X X X X X X X X X X X X");
  CONDITION = 0;
} else {
  console.log("# =============================== #\n# ========= NORMAL MODE ========= #\n# =============================== #");
}

if (mode === "{{ mode }}") {
  DEMO = true;
  CONDITION = 0;
}


// condition variables
CONDITION = parseInt(condition);

if(CONDITION == 0)
{
  CONDITION_TYPE = 'experimental';
}
else if(CONDITION == 1)
{
  CONDITION_TYPE = 'control';
}
else
{
  CONDITION_TYPE = 'demo';
}




with_info = false;

with_reward = false;

//f with_feedback = with_reward || with_info;
with_feedback = false;

BLOCKS = void 0;

PARAMS = void 0;

TRIALS = void 0;

DEMO_TRIALS = void 0;

STRUCTURE = void 0;

N_TRIAL = void 0;

SCORE = 0;

calculateBonus = void 0;

getTrials = void 0;

CONSTANT_DELAY = 3;

psiturk = new PsiTurk(uniqueId, adServerLoc, mode);

psiturk.recordUnstructuredData('condition', CONDITION);
psiturk.recordUnstructuredData('condition_type', CONDITION_TYPE);

//psiturk.recordUnstructuredData 'with_feedback', with_feedback
psiturk.recordUnstructuredData('with_reward', with_reward);

psiturk.recordUnstructuredData('with_info', with_info);

saveData = function() {
  return new Promise(function(resolve, reject) {
    var timeout;
    timeout = delay(10000, function() {
      return reject('timeout');
    });
    return psiturk.saveData({
      error: function() {
        clearTimeout(timeout);
        console.log('Error saving data!');
        return reject('error');
      },
      success: function() {
        clearTimeout(timeout);
        console.log('Data saved to psiturk server.');
        return resolve();
      }
    });
  });
};

$(window).resize(function() {
  return checkWindowSize(800, 600, $('#jspsych-target'));
});

$(window).resize();

$(window).on('load', function() {
  console.log("On load start");
  var loadTimeout, slowLoad;
  // Load data and test connection to server.
  slowLoad = function() {
    var ref;
    return (ref = $('slow-load')) != null ? ref.show() : void 0;
  };
  loadTimeout = delay(12000, slowLoad);
  return delay(300, function() {
    var id;
    console.log('Loading data');
    PARAMS = {
      inspectCost: 1,
      startTime: Date(Date.now()),
      bonusRate: .002,
      // variance: ['2_4_24', '24_4_2'][CONDITION]
      branching: '312',
      with_feedback: with_feedback,
      condition: CONDITION,
      with_reward: with_reward,
      with_info: with_info
    };
    psiturk.recordUnstructuredData('params', PARAMS);
    if (PARAMS.variance) {
      id = `${PARAMS.branching}_${PARAMS.variance}`;
    } else {
      id = `${PARAMS.branching}`;
    }
    STRUCTURE = loadJson("static/json/julian.json");
    TRIALS = loadJson("static/json/train_trials.json");
    console.log(`loaded ${(TRIALS != null ? TRIALS.length : void 0)} trials`);
    getTrials = (function() {
      var idx, t;
      t = _.shuffle(TRIALS);
      idx = 0;
      return function(n) {
        idx += n;
        return t.slice(idx - n, idx);
      };
    })();
    if (DEBUG || TALK) {
      createStartButton();
      return clearTimeout(loadTimeout);
    } else {
      console.log('Testing saveData');
      if (DEMO) {
        clearTimeout(loadTimeout);
        return delay(500, createStartButton);
      } else {
        return saveData().then(function() {
          clearTimeout(loadTimeout);
          return delay(500, createStartButton);
        }).catch(function() {
          clearTimeout(loadTimeout);
          return $('#data-error').show();
        });
      }
    }
  });
});

createStartButton = function() {
  if (DEBUG || TALK) {
    console.log('createStartButton 1');
    initializeExperiment();
    return;
  }

  //f create start button manually to increase speed
  $('#jspsych-target').append("<div class='alert alert-info'>\n   To start the experiment click <b>Begin</b> below.\n</div>\n<div class='center'>\n  <button class='btn btn-primary btn-lg centered' id=\"Begin\">Begin</button>\n</div>");
  $('#Begin').click(function() {
    return initializeExperiment();
  });

  $('#load-icon').hide();
  $('#slow-load').hide();
  $('#success-load').hide();
  //return $('#load-btn').click(initializeExperiment);
};

/*
createStartButton = function() {
  if (DEBUG || TALK) {
    initializeExperiment();
    return;
  }
  //f TODO: check if its ok???
  if (false) {
    $('#jspsych-target').append("<div class='alert alert-info'>\n  <h3>Demo mode</h3>\n\n  To go through the task as if you were a participant,\n  click <b>Begin</b> above.<br>\n  To view replays of the participants\n  in our study, click <b>View Replays</b> below.\n</div>\n<div class='center'>\n  <button class='btn btn-primary btn-lg centered' id=\"view-replays\">View Replays</button>\n</div>");
    $('#view-replays').click(function() {
      SHOW_PARTICIPANT = true;
      DEMO_TRIALS = _.shuffle(loadJson("static/json/demo/312.json"));
      return initializeExperiment();
    });
  }
  $('#load-icon').hide();
  $('#slow-load').hide();
  $('#success-load').show();
  return $('#load-btn').click(initializeExperiment);
};

*/
initializeExperiment = function() {
  var Block, ButtonBlock, MouselabBlock, QuizLoop, TextBlock, bonus_text, divider, divider_intro_training, divider_pretest_training, divider_training_test, experiment_timeline, extra_question_options, extra_questions, extra_questions_answers, extra_questions_required, finish, fullMessage, img, instruct_loop, instruction_pages, instructions, nodeValuesDescription, post_test, prompt_resubmit, quiz, reprompt, reset_score, save_data, survey, talk_demo, test_block_intro, text, train_basic1, training, verbal_responses;
  $('#jspsych-target').html('');
  console.log('INITIALIZE EXPERIMENT');
  //  ======================== #
  //  ========= TEXT ========= #
  //  ======================== #

  // These functions will be executed by the jspsych plugin that
  // they are passed to. String interpolation will use the values
  // of global variables defined in this file at the time the function
  // is called.
  text = {
    debug: function() {
      if (DEBUG) {
        return "`DEBUG`";
      } else {
        return '';
      }
    }
  };
  // ================================= #
  // ========= BLOCK CLASSES ========= #
  // ================================= #
  Block = class Block {
    constructor(config) {
      _.extend(this, config);
      this._block = this; // allows trial to access its containing block for tracking state
      if (this._init != null) {
        this._init();
      }
    }

  };
  TextBlock = (function() {
    class TextBlock extends Block {};

    TextBlock.prototype.type = 'text';

    TextBlock.prototype.cont_key = [];

    return TextBlock;

  }).call(this);
  ButtonBlock = (function() {
    class ButtonBlock extends Block {};

    ButtonBlock.prototype.type = 'button-response';

    ButtonBlock.prototype.is_html = true;

    ButtonBlock.prototype.choices = ['Continue'];

    ButtonBlock.prototype.button_html = '<button class="btn btn-primary btn-lg">%choice%</button>';

    return ButtonBlock;

  }).call(this);
  QuizLoop = class QuizLoop extends Block {
    loop_function(data) {
      var c, i, len, ref;
      console.log('data', data);
      ref = data[data.length].correct;
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        if (!c) {
          return true;
        }
      }
      return false;
    }

  };
  MouselabBlock = (function() {
    class MouselabBlock extends Block {
      _init() {
        _.extend(this, STRUCTURE);
        return this.trialCount = 0;
      }

    };

    MouselabBlock.prototype.type = 'mouselab-mdp';

    MouselabBlock.prototype.playerImage = 'static/images/monkey.png';

    // moveDelay: PARAMS.moveDelay
    // clickDelay: PARAMS.clickDelay
    // moveEnergy: PARAMS.moveEnergy
    // clickEnergy: PARAMS.clickEnergy
    MouselabBlock.prototype.lowerMessage = "<b>Clicking on a node reveals its value for a $1 fee.<br>\nMove with the arrow keys.</b>";

    return MouselabBlock;

  }).call(this);



  //  ============================== #
  //  ========= HELPER ========= #
  //  ============================== #
  img = function(name) {
    return `<img class='display' src='static/images/${name}.png'/>`;
  };
  nodeValuesDescription = (function() {
    switch (PARAMS.variance) {
      case "6_6_6":
        return "A node can have value -10, -5, 5, or 10. All values are equally likely.";
      case "2_4_24":
        return "The more steps it takes to reach a node, the more variable its value\ntends to be: The value of a node you can reach in **one** step is equally\nlikely to be **-4, -2, 2, or 4**. The value of a node you can reach in **two**\nsteps is equally likely to be **-8, -4, 4, or 8**. Finally,  the value of a\nnode you can reach in **three** steps is equally likely to be **-48, -24, 24,\nor 48**.";
      case "24_4_2":
        return "The more steps it takes to reach a node, the less variable its value\ntends to be: The value of a node you can reach in **one** step is equally\nlikely to be **-48, -24, 24, or 48**. The value of a node you can reach in\n**two** steps is equally likely to be **-8, -4, 4, or 8**. Finally,  the value\nof a node you can reach in **three** steps is equally likely to be -4, -2,\n2, or 4.";
    }
  })();



  //  ============================== #
  //  ========= EXPERIMENT TIMELINE ========= #
  //  ============================== #



  // MOUSELAB INSTRCUTION BLOCK --------------------------------

  instructions_0 = new Block({
    type: 'instructions',
    show_clickable_nav: true,
    pages: function()
    {
      return [markdown("<h1>Structure of the HIT</h1>\n\n In this HIT, you will participate in a psychology experiment. This experiment has two phases: \n\n- **Instructions:** In this phase, you will be introduced to a certain game and will be given instructions on how to play it. \n\n- **Test:** In this phase, you will be tested on your ability to follow a good strategy that does well in that game.\n\nIf you complete the HIT, you will receive a base pay of $0.15 and a bonus which is dependent on your performance in the test phase. On average, a person participating in the experiment receives $0.5.\n\n Click **Next** to start the **Instructions** part.")];
    }
  });

    instructions_1 = new Block({
    type: 'instructions',
    show_clickable_nav: true,
    pages: function()
    {
      return [
	markdown("<h1>Tree of Cash </h1>\n\nIn this HIT, you will help a\n money-loving monkey to swing through a tree. When you land on a gray circle\n (a ***node***) the value revealed by the node is added to the monkey's total reward. The monkey's goal is to make that total reward **as high as possible**. \n\nYou will be able to move the monkey with the arrow keys, but only in the direction\n of the arrows between the nodes. For simplicity, arrows that go up-left and up-right are mapped to the left arrow key and the right arrow key respectively.\n\n The image below shows the tree that you will be guiding the monkey through when the game starts.\n\n<img class='display' style=\"width:50%; height:auto\" src='static/images/tree-of-cash-unrevealed.png'/>"),
	markdown("   <h1> Node Inspector</h1>\n\n It is hard to decide where to go when you don't know the rewards. Fortunately, you can use a ***node inspector*** to reveal\n the value of any node. \n\nTo use the node inspector, you have to simply **click on a node**. \n\n However, each click takes away <span style='color: red;'> **$1**  </span> from the monkey. To understand how it all works, you can look at the image below. \n\n **Note:** You can only use the node inspector when you're on the initial\n node, i.e. before you have moved.\n\n \n\n<img class='display' style=\"width:70%; height:auto\" src='static/images/tree-of-cash.png'/>")];
    }
  });

  tryout1 = new Block({
    type: 'instructions',
    show_clickable_nav: true,
    pages: function(){
      SCORE = 0;
      return [markdown("   <h1> Practice</h1>\n\n In the next round, you will be given a chance to try out the node inspector and move the monkey so that you get used to the game.\n\n**Enjoy!**\n\n</div>")];
    }
  });

  practice = new MouselabBlock({
    showMoneyMade: true,
    showRightImage: false,
    rightMessage: '\xa0'.repeat(8) + 'Score: <span id=mouselab-score/>',
    minTime: DEBUG ? 1 : 7,
    postTrialDelay: true || DEBUG ? 1 : 11,
    clickDelay: 0,
    show_feedback: with_feedback,
    blockName: 'practice',
    stateDisplay: 'click',
    stateClickCost: PARAMS.inspectCost,
    timeline: (function() {
      switch (false) {
        case !SHOW_PARTICIPANT:
          return DEMO_TRIALS;
        default:
          // when DEBUG then TRIALS.slice(6, 8)
          return getTrials(1);
      }
    })(),
    startScore: 50
  });

  instruct_mouselab = new Block({
    timeline: [instructions_0, instructions_1, tryout1, practice]
  });



  // condition 2 ---------

  instructions_0_condition2 = new Block({
    type: 'instructions',
    show_clickable_nav: true,
    pages: function()
    {
      return [markdown("<h1>Structure of the HIT</h1>\n\n In this HIT, you will participate in a psychology experiment. This experiment has two phases: \n\n- **Instructions:** In this phase, you will be introduced to a certain game and will be given instructions on how to play it. \n\n- **Test:** In this phase, you will be tested on your ability to do well in that game.\n\nIf you complete the HIT, you will receive a base pay of $0.15 and a bonus which is dependent on your performance in the test phase. On average, a person participating in the experiment receives $0.5.")];
    }
  });

    instructions_1_condition2 = new Block({
    type: 'instructions',
    show_clickable_nav: true,
    pages: function()
    {
      return [
    	markdown("<h1>Tree of Cash </h1>\n\nIn this HIT, you will help a\n money-loving monkey to swing through a tree. When you land on a gray circle\n (a ***node***) the value revealed by the node is added to the monkey's total reward. The monkey's goal is to make that total reward **as high as possible**. \n\nYou will be able to move the monkey with the arrow keys, but only in the direction\n of the arrows between the nodes. For simplicitty, arrows that go up-left and up-right are mapped to the left arrow key and the right arrow key respectively.\n\n The image below shows the tree that you will be guiding the monkey through when the game starts.\n\n<img class='display' style=\"width:50%; height:auto\" src='static/images/tree-of-cash-unrevealed.png'/>"),
    	markdown("   <h1> Node Inspector</h1>\n\n It is hard to decide where to go when you don't know the rewards. Fortunately, you can use a ***node inspector*** to reveal\n the value of any node. \n\nTo use the node inspector, you have to simply **click on a node**. \n\n However, each click takes away <span style='color: red;'> **1$**  </span> from the monkey. To understand how it all works, you can look at the image below. \n\n **Note:** You can only use the node inspector when you're on the initial\n node, i.e. before you have moved.\n\n \n\n<img class='display' style=\"width:75%; height:auto\" src='static/images/tree-of-cash.png'/>")];
        }
    });

  tryout1_condition2 = new Block({
    type: 'instructions',
    show_clickable_nav: true,
    pages: function(){
      SCORE = 0;
      return [markdown("   <h1> Practice</h1>\n\n In the next three rounds, you will be given a chance to try out the node inspector and move the monkey so that you get used to the game.\n\n**Enjoy!**\n\n</div>")];
    }
  });

  practice_condition2 = new MouselabBlock({
    showMoneyMade: true,
    showRightImage: false,
    minTime: DEBUG ? 1 : 7,
    postTrialDelay: true || DEBUG ? 1 : 11,
    clickDelay: 0,
    show_feedback: with_feedback,
    blockName: 'practice',
    stateDisplay: 'click',
    stateClickCost: PARAMS.inspectCost,
    timeline: (function() {
      switch (false) {
        case !SHOW_PARTICIPANT:
          return DEMO_TRIALS;
        default:
          // when DEBUG then TRIALS.slice(6, 8)
          return getTrials(3);
      }
    })(),
    startScore: 50
  });


  instruct_mouselab_condition2 = new Block({
    timeline: [instructions_0_condition2, instructions_1_condition2, tryout1_condition2, practice_condition2]
  });


  // DT INSTRCUTION BLOCK --------------------------------
  leaf_instructions_2 = new Block({
    type: 'instructions',
    show_clickable_nav: true,
    pages: function()
    {
      return [
	markdown("<h1>Flowchart </h1>\n\n The node inspector isn't helpful however, when you don't know **where** to click. After all, each click costs $1 and there is nothing known about the location of the rewards. \n\n To help you make decisions about clicking, you will be shown a very good strategy that allows the monkey to get a lot of cash. Your main task in this experiment will be to **follow that strategy**. Your **bonus** will depend on how well you do that!\n\n- Formally, the strategy takes form of a ***flowchart*** describing which kinds of nodes you should **click** on. \n- To use the flowchart, **think of a particular node**. \n- The flowchart walks you through a list of questions that ask something about that node (or the tree in general).\n- Your answers lead to a decision: <span style='color: green;'> **CLICK IT** </span> or <span style='color: red;'> **DON'T CLICK IT** </span>. \n\nTo see a sample flowchart, look at the image below. \n\n<img class='display' style=\"width:50%; height:auto\" src='static/images/DT1.png'/>\n\n Don't worry if you didn't fully grasp it! Click **Next** to learn about the terms used in the flowchart."),
	markdown("<h1>Terms Used in the Flowchart </h1>\n\nAs you might have already noticed, some questions the flowchart will ask use words that have a special meaning in this game. They are as follows: \n\n- A node that is grey and was not yet clicked is called an ***unobserved*** node. A node that was already clicked and revealed a positive or a negative reward is called an ***observed*** node. \n- The tree has 3 ***levels*** defined by the horizontal alignment of the nodes. \n- The nodes of ***higher*** levels are ***higher*** up in the tree. That is, the nodes of Level 3 are above the nodes of Level 2 and the nodes of Level 2 are above the nodes of Level 1. \n- A ***leaf*** is any node that does not have outgoing connections (arrows) to other nodes in the tree. \n\nSee the image below to get a better sense of these notions. \n\n<img class='display' style=\"width:75%; height:auto\" src='static/images/tree-glossary.png'/>"),
	markdown("<h1>Hint: Reading the Flowchart </h1>\n\n To read the flowchart effectively, try to understand which nodes should be clicked. Do that by looking at the questions and deciding which statements need to be true in order to arrive to <span style='color: green;'> **CLICK IT** </span> decisions. If you clicked **all** the nodes allowed by the flowchart (that is all those that led to <span style='color: green;'> **CLICK IT** </span> decision), you should start navigating the monkey so that it gets the highest possible reward. Your goals should be the following: \n- Consult the flowchart and try to understand which nodes you should click. \n- Click on all of those nodes. \n- Move the monkey through the tree so as to collect as much reward as possible. To choose monkey’s path, it is enough to only look at the rewards of the observed nodes and ignore the unobserved nodes.")];
    }
  });

      tryout2 = new Block({
    type: 'instructions',
    show_clickable_nav: true,
    pages: function(){
      SCORE = 0;
      return [markdown("   <h1> Practice </h1>\n\n In the next two rounds you will get to know with how to make decisions about clicking with the help of the flowchart. \n\n Remember! The flowchart describes which kinds of nodes you should click on. Please click on all of those nodes until none of them is left. When that happens, it's time to swing the monkey through the tree.\n\n *Try it out on the next page!* \n")];
    }
  });

    practice2 = new MouselabBlock({
      rightMessage: "",
      showMoneyMade: true,
      showRightImage: true,
      rightImageSrc: 'static/images/DT2.png',
      rightImageWidth: "25%",
      lowerMessage: '<b>Before making a click, consult the flowchart on your right.<br>\nMove with the arrow keys.</b>',
      minTime: DEBUG ? 1 : 7,
      postTrialDelay: true || DEBUG ? 1 : 11,
      clickDelay: 0,
      show_feedback: false,
      show_custom_feedback: false,
      blockName: 'practice2',
      stateDisplay: 'click',
      stateClickCost: PARAMS.inspectCost,
      timeline: (function() {
        switch (false) {
          case !SHOW_PARTICIPANT:
            return DEMO_TRIALS;
          default:
            // when DEBUG then TRIALS.slice(6, 8)
            return getTrials(2);
        }
      })(),
      startScore: 50
    });

    quiz1 = new Block({
    preamble: function() {
      return markdown("# Quiz\n\nPlease answer the following questions about the *Tree of Cash* game\n");
    },
    type: 'survey-multi-choice',
    questions: ["What is your task in the game?", "How should you make decisions about where to click?", "When should you start climbing the monkey up the tree?", "What is a leaf node?", "What is an unobserved node?"],
    options: [['Follow a strategy of clicking in the Tree of Cash game that is conveyed by a flowchart.', 'Collect all the possible rewards in the tree.', 'Climb the monkey up the top of the tree.'], ['I can click randomly.', 'By understanding the strategy conveyed by the flowchart.', 'Based on the expert demonstrations.', ], ['After all the nodes were clicked.', "When all the nodes that led to CLICK IT decision according to the flowchart were clicked.", 'Based on a careful computation of expected rewards.', ], ['A node on the lowest level of the tree.', 'Any node in the tree that revealed a positive reward.', 'A node without outgoing connections.'], ['Any node the monkey is currently on.', 'A node which has not been clicked in the current trial.', 'A node that has never been clicked in any of the previous trials.']],
    required: [true, true, true, true, true],
    correct: ['Follow a strategy of clicking in the Tree of Cash game that is conveyed by a flowchart.', 'By understanding the strategy conveyed by the flowchart.', "When all the nodes that led to CLICK IT decision according to the flowchart were clicked.", 'A node without outgoing connections.', 'A node which has not been clicked in the current trial.']
  });


  instruct_DT_loop = new Block({
    timeline: [leaf_instructions_2, tryout2, practice2, quiz1],
    loop_function: function(data) {
      var c, i, len, ref;
      console.log(data);
      ref = data[data.length-1].correct;
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        if (!c) {
          alert("You got at least one question wrong. We'll send you back to the\ninstructions and then you can try again.");
          return true; // try again
        }
      }
      psiturk.finishInstructions();
      psiturk.saveData();
      return false;
    }
  });



  // condition 2 ----

  notree_instructions_2 = new Block({
    type: 'instructions',
      show_clickable_nav: true,
      pages: function()
      {
        return [
          markdown("<h1>Goal </h1>\n\n The node inspector is helpful only when you know **where** to click. Try to figure that out and help the monkey to get as much cash as possible. The more cash you collect, the larger **bonus** you will get!\n\n")];
      }
    });

  quiz1_condition2 = new Block({
    preamble: function() {
      return markdown("# Quiz\n\nPlease answer the following questions about the *Tree of Cash* game\n");
    },
    type: 'survey-multi-choice',
    questions: ["What is your task in the game?", "How should you make decisions about where to click?", "What is a node?"],
    options: [['Maximize the total reward of the monkey.', 'Collect all the possible rewards in the tree.', 'Climb the monkey up the top of the tree.'],
              ['By following a strategy that will be shown to me.', 'By figuring out how to use the node inspector in the most intelligent way.', 'Based on the expert demonstrations.' ],
              ['Every grey circle in the tree.', "The circle the monkey is currently on.", 'An arrow that connects two circles of the tree.']],
    required: [true, true, true],
    correct: ['Maximize the total reward of the monkey.', 'By figuring out how to use the node inspector in the most intelligent way.', "Every grey circle in the tree."]
  });

  instruct_DT_loop_condition2 = new Block({
    timeline: [notree_instructions_2, quiz1_condition2],
    loop_function: function(data) {
      var c, i, len, ref;
      console.log(data);
      ref = data[data.length-1].correct;
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        if (!c) {
          alert("You got at least one question wrong. We'll send you back to the\ninstructions and then you can try again.");
          return true; // try again
        }
      }
      psiturk.finishInstructions();
      psiturk.saveData();
      return false;
    }
  });


  // TESTING BLOCK --------------------------------
  testing_intro = new Block({
    type: 'instructions',
    show_clickable_nav: true,
    pages: function(){
      SCORE = 0;
      return [markdown("   <h1> Test Block </h1>\n\n In the next ten rounds you will be tested how well you can follow a flowchart. The more accurate you are, the larger **bonus** you will get. The flowchart will not change during the trials.\n\n Remember! The flowchart describes which kinds of nodes you should click on. Please click on all of those nodes until none of them is left. When that happens, it's time to swing the monkey through the tree.\n\n *Start the test on the next page. Good luck!* \n")];
    }
  });


  testing = new MouselabBlock({
    rightMessage: "",
    showMoneyMade: true,
    showRightImage: true,
    rightImageWidth: "43%",
    rightImageSrc: 'static/images/DT1.png',
    lowerMessage: '<b>Before making a click, consult the flowchart on your right.<br>\nMove with the arrow keys.</b>',
    minTime: DEBUG ? 1 : 7,
    postTrialDelay: true || DEBUG ? 1 : 11,
    clickDelay: 0,
    show_feedback: with_feedback,
    blockName: 'testing',
    stateDisplay: 'click',
    stateClickCost: PARAMS.inspectCost,
    timeline: (function() {
      switch (false) {
        case !SHOW_PARTICIPANT:
          return DEMO_TRIALS;
        default:
          // when DEBUG then TRIALS.slice(6, 8)
          return getTrials(10);
      }
    })(),
    startScore: 50
  });

    testing_block = new Block({
      timeline: [testing_intro, testing]
    });


  // condition 2 -----
  testing_intro_condition2 = new Block({
    type: 'instructions',
    show_clickable_nav: true,
    pages: function(){
      SCORE = 0;
      return [markdown("   <h1> Test Block </h1>\n\n In the next ten rounds you will be tested how well you can play the game.\n\n Remember! The higher the monkey's total reward, the larger **bonus** you will get.\n\n *Start the test on the next page. Good luck!* \n")];
    }
  });

  testing_condition2 = new MouselabBlock({
    showMoneyMade: true,
    showRightImage: false,
    lowerMessage: '<b>Clicking on a node reveals its value for a $1 fee.<br>\nMove with the arrow keys.</b>',
    minTime: DEBUG ? 1 : 7,
    postTrialDelay: true || DEBUG ? 1 : 11,
    clickDelay: 0,
    show_feedback: with_feedback,
    blockName: 'testing',
    stateDisplay: 'click',
    stateClickCost: PARAMS.inspectCost,
    timeline: (function() {
      switch (false) {
        case !SHOW_PARTICIPANT:
          return DEMO_TRIALS;
        default:
          // when DEBUG then TRIALS.slice(6, 8)
          return getTrials(10);
      }
    })(),
    startScore: 50
  });

  testing_block_condition2 = new Block({
    timeline: [testing_intro_condition2, testing_condition2]
  });


  // END BLOCK --------------------------------
  final_survey = new Block({
    type: 'survey-text',
    preamble: function() {
      return markdown("# Please, answer the following questions:\n    ");
    },
    questions: ['Did you understand the strategy that the tree was conveying?', 'How would you describe the strategy to a friend?', 'What is your age?', 'Which gender do you identify with?'],
    button: 'Next'
  });

  final_edu_survey = new Block({
    preamble: function() {
      return markdown("You are almost done. Please answer the following questions:");
    },
    type: 'survey-multi-choice',
    questions: ["What is the highest degree or level of school you have completed?",
                "Did you have prior training in computer science?"],
    options: [ ['No schooling completed', 'High school graduate', 'College degree'],
               ['Yes', 'No']],
    button_label: 'Finish'
  });

  finish = new Block({
    type: 'survey-text',
    preamble: function() {
      return markdown(`# You've completed the HIT\n\n Feel free to give us feedback below before you submit the HIT.\n\n You'll be awarded a bonus based on your performance in 24 hours after the end of the experiment. \n\n Please click on the **"Complete HIT"** button that appears on your dashboard after you submit the HIT here. \n\n Thank you for participating! Hope you enjoyed!`);
    },
    questions: ['Any comments/feedback?'],
    button: 'Submit HIT'
  });

  end_block = new Block({
    timeline: [final_survey, final_edu_survey, finish]
  });


  // condition 2----
  final_survey_condition2 = new Block({
    type: 'survey-text',
    preamble: function() {
      return markdown("# Please, answer the following questions:\n    ");
    },
    questions: ['What is your age?', 'Which gender do you identify with?'],
    button: 'Next'
  });

  end_block_condition2 = new Block({
    timeline: [final_survey_condition2, final_edu_survey, finish]
  });


  experiment_timeline = (function() {
    if(CONDITION == 0){
      console.log("-- Experimental timeline");
      return [instruct_mouselab, instruct_DT_loop, testing_block, end_block];
    } else if (CONDITION == 1) {
      console.log(" -- Control timeline");
      return [instruct_mouselab_condition2 , instruct_DT_loop_condition2, testing_block_condition2, end_block_condition2];
    } else {
      console.log(" -- Demo timeline");
      return [end_block_condition2];
    }
  })();


  // ================================================ #
  // ========= START AND END THE EXPERIMENT ========= #
  // ================================================ #

  // bonus is the total score multiplied by something
  calculateBonus = function() {
    var bonus;
    bonus = SCORE * PARAMS.bonusRate;
    bonus = (Math.round(bonus * 100)) / 100; // round to nearest cent
    return Math.max(0, bonus);
  };
  reprompt = null;
  save_data = function() {
    return psiturk.saveData({
      success: function() {
        console.log('Data saved to psiturk server.');
        if (reprompt != null) {
          window.clearInterval(reprompt);
        }
        //return psiturk.computeBonus('compute_bonus', psiturk.completeHIT);
        psiturk.completeHIT();
      },
      error: function() {
        return prompt_resubmit;
      }
    });
  };
  prompt_resubmit = function() {
    $('#jspsych-target').html("<h1>Oops!</h1>\n<p>\nSomething went wrong submitting your HIT.\nThis might happen if you lose your internet connection.\nPress the button to resubmit.\n</p>\n<button id=\"resubmit\">Resubmit</button>");
    return $('#resubmit').click(function() {
      $('#jspsych-target').html('Trying to resubmit...');
      reprompt = window.setTimeout(prompt_resubmit, 10000);
      return save_data();
    });
  };
  return jsPsych.init({
    display_element: $('#jspsych-target'),
    timeline: experiment_timeline,
    // show_progress_bar: true
    on_finish: function() {
      if (DEBUG) {
        return jsPsych.data.displayData();
      } else {
        // psiturk.recordUnstructuredData('final_bonus', calculateBonus());
        return save_data();
      }
    },
    on_data_update: function(data) {
      console.log('data', data);
      return psiturk.recordTrialData(data);
    }
  });
};
