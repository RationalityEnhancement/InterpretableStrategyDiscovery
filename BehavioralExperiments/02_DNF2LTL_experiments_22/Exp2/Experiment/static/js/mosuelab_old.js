// Generated by CoffeeScript 2.2.2
/*
jspsych-mouselab-mdp.coffee
Fred Callaway

https://github.com/fredcallaway/Mouselab-MDP
*/
var D, LOADING, SCORE, TIME_LEFT, WATCH, mdp,
    indexOf = [].indexOf;

// coffeelint: disable=max_line_length
mdp = void 0;

D = void 0;

WATCH = {};

SCORE = 0;

TIME_LEFT = void 0;

LOADING = '';

jsPsych.plugins['mouselab-mdp'] = (function () {
    var Arrow, Edge, KEYS, LOG_DEBUG, LOG_INFO, MouselabMDP, NULL, PRINT, RIGHT_MESSAGE, SIZE, State, Note, TOP_ADJUST,
        LEFT_ADJUST, TRIAL_INDEX, Text, angle, checkObj, dist, plugin, polarMove, redGreen, removePrivate, round,
        Flowchart, Tutor, Instructions;
    PRINT = function (...args) {
        return console.log(...args);
    };
    NULL = function (...args) {
        return null;
    };
    LOG_INFO = PRINT;
    LOG_DEBUG = NULL;
    // a scaling parameter, determines size of drawn objects
    SIZE = void 0;
    TRIAL_INDEX = 0;

    TOP_ADJUST = 40;
    LEFT_ADJUST = -10;

    fabric.Object.prototype.originX = fabric.Object.prototype.originY = 'center';
    fabric.Object.prototype.selectable = false;
    fabric.Object.prototype.hoverCursor = 'default';
    // =========================== #
    // ========= Helpers ========= #
    // =========================== #
    removePrivate = function (obj) {
        return _.pick(obj, (function (v, k, o) {
            return !k.startsWith('_');
        }));
    };
    angle = function (x1, y1, x2, y2) {
        var ang, x, y;
        x = x2 - x1;
        y = y2 - y1;
        if (x === 0) {
            ang = y === 0 ? 0 : y > 0 ? Math.PI / 2 : Math.PI * 3 / 2;
        } else if (y === 0) {
            ang = x > 0 ? 0 : Math.PI;
        } else {
            ang = x < 0 ? Math.atan(y / x) + Math.PI : y < 0 ? Math.atan(y / x) + 2 * Math.PI : Math.atan(y / x);
        }
        return ang + Math.PI / 2;
    };
    polarMove = function (x, y, ang, dist) {
        x += dist * Math.sin(ang);
        y -= dist * Math.cos(ang);
        return [x, y];
    };
    dist = function (o1, o2) {
        return Math.pow(Math.pow(o1.left - o2.left, 2) + Math.pow(o1.top - o2.top, 2), 0.5);
    };
    redGreen = function (val) {
        if (val > 0) {
            return '#080';
        } else if (val < 0) {
            return '#b00';
        } else {
            return '#666';
        }
    };
    redGreenNotes = function (val) {
        if (val > 0) {
            return '#458c45';
        } else if (val < 0) {
            return '#b84f4f';
        } else {
            return '#666';
        }
    };
    round = function (x) {
        return (Math.round(x * 100)) / 100;
    };
    checkObj = function (obj, keys) {
        var i, k, len;
        if (keys == null) {
            keys = Object.keys(obj);
        }
        for (i = 0, len = keys.length; i < len; i++) {
            k = keys[i];
            if (obj[k] === void 0) {
                console.log('Bad Object: ', obj);
                throw new Error(`${k} is undefined`);
            }
        }
        return obj;
    };
    KEYS = mapObject({
        up: 'uparrow',
        down: 'downarrow',
        right: 'rightarrow',
        left: 'leftarrow',
        simulate: 'space'
    }, jsPsych.pluginAPI.convertKeyCharacterToKeyCode);
    RIGHT_MESSAGE = '\xa0'.repeat(8) + 'Score: <span id=mouselab-score/>';
    // =============================== #
    // ========= MouselabMDP ========= #
    // =============================== #
    MouselabMDP = class MouselabMDP {
        constructor(config) {
            var blockName, centerMessage, leftMessage, lowerMessage, prompt, rightMessage, size, trial_id;
            this.runDemo = this.runDemo.bind(this);
            this.startTimer = this.startTimer.bind(this);
            // ---------- Responding to user input ---------- #

            // Called when a valid action is initiated via a key press.
            this.handleKey = this.handleKey.bind(this);
            this.startSimulationMode = this.startSimulationMode.bind(this);
            this.endSimulationMode = this.endSimulationMode.bind(this);
            this.getOutcome = this.getOutcome.bind(this);
            this.encodeBelief = this.encodeBelief.bind(this);
            this.getReward = this.getReward.bind(this);
            this.move = this.move.bind(this);
            this.clickState = this.clickState.bind(this);
            this.preClickState = this.preClickState.bind(this);
            this.showFeedback = this.showFeedback.bind(this);
            this.clearFeedback = this.clearFeedback.bind(this);
            this.mouseoverState = this.mouseoverState.bind(this);
            this.mouseoutState = this.mouseoutState.bind(this);
            this.clickEdge = this.clickEdge.bind(this);
            this.mouseoverEdge = this.mouseoverEdge.bind(this);
            this.mouseoutEdge = this.mouseoutEdge.bind(this);
            this.getEdgeLabel = this.getEdgeLabel.bind(this);
            this.recordQuery = this.recordQuery.bind(this);
            // ---------- Updating state ---------- #

            // Called when the player arrives in a new state.
            this.arrive = this.arrive.bind(this);
            this.addScore = this.addScore.bind(this);
            this.resetScore = this.resetScore.bind(this);
            this.drawScore = this.drawScore.bind(this);
            this.spendEnergy = this.spendEnergy.bind(this);
            // $('#mouselab-').css 'color', redGreen SCORE

            // ---------- Starting the trial ---------- #
            this.run = this.run.bind(this);
            // Draw object on the canvas.
            this.draw = this.draw.bind(this);
            // Draws the player image.
            this.initPlayer = this.initPlayer.bind(this);
            // Constructs the visual display.
            this.buildMap = this.buildMap.bind(this);
            // ---------- ENDING THE TRIAL ---------- #

            // Creates a button allowing user to move to the next trial.
            this.endTrial = this.endTrial.bind(this);
            this.checkFinished = this.checkFinished.bind(this);
            // @transition=null  # function `(s0, a, s1, r) -> null` called after each transition

            //f add leaves already clicked alrady made
            this.num_clicked_leaves = 0;
            this.selected = [];
            this.pre_selected = '-';

            // leftMessage="Round: #{TRIAL_INDEX}/#{N_TRIAL}" //MATEO this.revelaed
            ({
                display: this.display,
                graph: this.graph,
                layout: this.layout,
                initial: this.initial,
                stateLabels: this.stateLabels = 'reward',
                stateDisplay: this.stateDisplay = 'never',
                stateClickCost: this.stateClickCost = 0,
                edgeLabels: this.edgeLabels = 'never',
                edgeDisplay: this.edgeDisplay = 'always',
                edgeClickCost: this.edgeClickCost = 0,
                stateRewards: this.stateRewards = null,
                revealed: this.revealed = null,
                clickDelay: this.clickDelay = 0,
                moveDelay: this.moveDelay = 500,
                clickEnergy: this.clickEnergy = 0,
                moveEnergy: this.moveEnergy = 0,
                startScore: this.startScore = 0,
                actions: this.actions = null,
                clicks: this.clicks = null,
                pid: this.pid = null,
                show_feedback: this.show_feedback = false,
                postTrialDelay: this.postTrialDelay = 0,
                allowSimulation: this.allowSimulation = false,
                revealRewards: this.revealRewards = true,
                training: this.training = false,
                special: this.special = '',
                timeLimit: this.timeLimit = null,
                minTime: this.minTime = null,
                energyLimit: this.energyLimit = null,
                qs: this.qs = null,
                keys: this.keys = KEYS,
                trialIndex: this.trialIndex = TRIAL_INDEX,
                playerImage: this.playerImage = 'static/images/plane.png',
                size = 75,
                trial_id = null,
                blockName = 'none',
                prompt = '&nbsp;',
                leftMessage = '',
                centerMessage = '&nbsp;',
                rightMessage = RIGHT_MESSAGE,
                lowerMessage = '&nbsp;',
                rightImageSrc: this.rightImageSrc = 'static/images/plane.png',
                showRightImage: this.showRightImage = false,
                rightImageWidth: this.rightImageWidth = "30%",
                showMoneyMade: this.showMoneyMade = true,
                show_interactive_instructions: this.show_interactive_instructions = false,
                instructions_config: this.instructions_config = {},
                show_interactive_flowchart: this.show_interactive_flowchart = false,
                flowchart_config: this.flowchart_config = {},
                show_custom_feedback: this.show_custom_feedback = false,
                show_path_rewards: this.show_path_rewards = false,
                show_pre_select: this.show_pre_select = false,
                confirmMessage: this.confirmMessage = null
            } = config); // html display element // defines transition and reward functions // defines position of states // initial state of player // object mapping from state names to labels // one of 'never', 'hover', 'click', 'always' // subtracted from score every time a state is clicked // object mapping from edge names (s0 + '__' + s1) to labels // one of 'never', 'hover', 'click', 'always' // subtracted from score every time an edge is clicked // mapping from actions to keycodes // number of trial (starts from 1) // determines the size of states, text, etc...
            this.termAction = `${this.stateRewards.length}`;
            if (this.pid != null) {
                this.showParticipant = true;
                centerMessage = `Participant ${this.pid}`;
            }
            SIZE = size;
            _.extend(this, config);
            checkObj(this);
            if (this.stateLabels === 'reward') {
                this.stateLabels = this.stateRewards;
            }
            this.stateLabels[0] = '';
            if (this.energyLimit) {
                leftMessage = 'Energy: <b><span id=mouselab-energy/></b>';
                if (this._block.energyLeft == null) {
                    this._block.energyLeft = this.energyLimit;
                }
            } else {
                if (leftMessage.length == 0) {
                    leftMessage = `Quiz Round ${this._block.trialCount + 1}/${this._block.timeline.length}`;
                }
            }
            // leftMessage = "Round #{@_block.trialCount + 1}/#{@_block.timeline.length}"
            this.data = {
                stateRewards: this.stateRewards,
                trial_id: trial_id,
                block: blockName,
                trialIndex: this.trialIndex,
                score: 0,
                expectedScore: 0,
                expectedRewards: 0,
                simulationMode: [],
                rewards: [],
                path: [],
                rt: [],
                delays: [],
                actions: [],
                actionTimes: [],
                queries: {
                    preselect: {
                        state: {
                            'target': [],
                            'time': []
                        },
                        clickable: {
                            'target': [],
                            'time': []
                        }
                    },
                    click: {
                        state: {
                            'target': [],
                            'time': []
                        },
                        edge: {
                            'target': [],
                            'time': []
                        },
                        clickable: {
                            'target': [],
                            'time': []
                        }
                    },
                    flowchart: {
                        index: {
                            'target': [],
                            'time': []
                        },
                        answer: {
                            'target': [],
                            'time': []
                        },
                        correct: {
                            'target': [],
                            'time': []
                        },
                        answer_stats: {
                            'total': [],
                            'correct': [],
                        }
                    },
                    quiz_selection: {
                        'gt': [],
                        'answer': [],
                        'tp': [],
                        'fp': [],
                        'tn': [],
                        'fn': [],
                        'num_tp': 0,
                        'num_fp': 0,
                        'num_tn': 0,
                        'num_fn': 0,
                    },
                    mouseover: {
                        state: {
                            'target': [],
                            'time': []
                        },
                        edge: {
                            'target': [],
                            'time': []
                        }
                    },
                    mouseout: {
                        state: {
                            'target': [],
                            'time': []
                        },
                        edge: {
                            'target': [],
                            'time': []
                        }
                    }
                }
            };
            if ($('#mouselab-msg-right').length) { // right message already exists
                this.leftMessage = $('#mouselab-msg-left');
                this.leftMessage.html(leftMessage);
                this.centerMessage = $('#mouselab-msg-center');
                this.centerMessage.html(centerMessage);
                this.rightMessage = $('#mouselab-msg-right');
                this.rightMessage.html(rightMessage);
                this.stage = $('#mouselab-stage');
                this.prompt = $('#mouselab-prompt');
                this.prompt.html(prompt);
                this.stageRow = $('#stage-row');
            } else {
                // @canvasElement = $('#mouselab-canvas')
                // @lowerMessage = $('#mouselab-msg-bottom')
                this.display.empty();
                // @display.css 'width', '1000px'

                // leftMessage = "Round: #{@trialIndex + 1}/#{@_block.timeline.length}"
                this.leftMessage = $('<div>', {
                    id: 'mouselab-msg-left',
                    class: 'mouselab-header',
                    html: leftMessage
                }).appendTo(this.display);
                this.centerMessage = $('<div>', {
                    id: 'mouselab-msg-center',
                    class: 'mouselab-header',
                    html: centerMessage
                }).appendTo(this.display);
                this.rightMessage = $('<div>', {
                    id: 'mouselab-msg-right',
                    class: 'mouselab-header',
                    html: rightMessage
                }).appendTo(this.display);
                if (prompt !== null) {
                    this.prompt = $('<div>', {
                        id: 'mouselab-prompt',
                        class: 'mouselab-prompt',
                        html: prompt
                    }).appendTo(this.display);
                }
                this.stage = $('<div>', {
                    id: 'mouselab-stage'
                }).appendTo(this.display);

                if (this.timeLimit) {
                    TIME_LEFT = this.timeLimit;
                }
                this.addScore(this.startScore);
            }
            // -----------------------------

            this.topMessage = $('<div>', {
                id: 'mouselab-msg-top',
                class: 'mouselab-msg-bottom',
                html: lowerMessage || '&nbsp'
            }).appendTo(this.stage);

            //f rightImage changes
            this.stageRow = $('<div>', {
                id: 'stage-row',
            }).appendTo(this.stage);


            this.canvasElement = $('<canvas>', {
                id: 'mouselab-canvas'
            }).appendTo(this.stageRow);

            // if right Image shall be dsiplayed
            if (this.showRightImage) {
                this.rightImage = $('<img>', {
                    id: 'mouselab-img-right',
                    src: this.rightImageSrc
                }).appendTo(this.stageRow);
                this.rightImage.width(this.rightImageWidth);
                this.stageRow.addClass('broad');
            }

            if (this.show_interactive_instructions) {
                this.instructionsContainer = $('<div>', {
                    id: 'mouselab-instructions-container',
                }).appendTo(this.stageRow);

                this.stageRow.addClass('broad');
                this.tutor = new Instructions(this.instructionsContainer, this.instructions_config);

            } else if (this.show_interactive_flowchart) {

                this.flowchartContainer = $('<div>', {
                    id: 'mouselab-flowchart-container',
                }).appendTo(this.stageRow);

                this.stageRow.addClass('broad');
                this.tutor = new Flowchart(this.flowchartContainer, this.flowchart_config);
            }

            this.lowerMessage = $('<div>', {
                id: 'mouselab-msg-bottom',
                class: 'mouselab-msg-bottom',
                html: '&nbsp'
            }).appendTo(this.stage);

            this.waitMessage = $('<div>', {
                id: 'mouselab-wait-msg',
                class: 'mouselab-msg-bottom'
                // html: """Please wait <span id='mdp-time'></span> seconds"""
            }).appendTo(this.display);
            this.waitMessage.hide();
            this.defaultLowerMessage = '&nbsp';

            // feedback element
            $('#jspsych-target').append("<div id=\"mdp-feedback\" class=\"modal\">\n  <div id=\"mdp-feedback-content\" class=\"modal-content\">\n    <h3>Default</h3>\n  </div>\n</div>");
            mdp = this;
            LOG_INFO('new MouselabMDP', this);
            this.invKeys = _.invert(this.keys);
            this.resetScore();
            this.spendEnergy(0);
            this.freeze = true;
            this.lowerMessage.css('color', '#000');

        }

        async runDemo() {
            var a, c, i, j, l, len, len1, len2, ref, ref1, ref2, results, results1, s, s1;
            this.timeLeft = 1;
            console.log('runDemo');
            ref = this.clicks;
            for (i = 0, len = ref.length; i < len; i++) {
                c = ref[i];
                await sleep(1000);
                console.log('click', c);
                this.clickState(this.states[c], c);
                this.canvas.renderAll();
            }
            if (this.actions != null) {
                ref1 = this.actions;
                results = [];
                for (j = 0, len1 = ref1.length; j < len1; j++) {
                    a = ref1[j];
                    await sleep(700);
                    s = _.last(this.data.path);
                    results.push(this.handleKey(s, a));
                }
                return results;
            } else {
                ref2 = this.demoStates;
                results1 = [];
                for (l = 0, len2 = ref2.length; l < len2; l++) {
                    s1 = ref2[l];
                    await sleep(700);
                    this.move(s, null, s1);
                    results1.push(s = s1);
                }
                return results1;
            }
        }

        startTimer() {
            var interval;
            this.timeLeft = this.minTime;
            this.waitMessage.html(`Please wait ${this.timeLeft} seconds`);
            interval = ifvisible.onEvery(1, () => {
                if (this.freeze) {
                    //return;
                }
                this.timeLeft -= 1;
                this.waitMessage.html(`Please wait ${this.timeLeft} seconds`);
                // $('#mdp-time').html @timeLeft
                // $('#mdp-time').css 'color', (redGreen (-@timeLeft + .1))  # red if > 0
                if (this.timeLeft === 0) {
                    interval.stop();
                    return this.checkFinished();
                }
            });
            $('#mdp-time').html(this.timeLeft);
            return $('#mdp-time').css('color', redGreen(-this.timeLeft + .1));
        }

        endBlock() {
            this.blockOver = true;
            jsPsych.pluginAPI.cancelAllKeyboardResponses();
            return this.keyListener = jsPsych.pluginAPI.getKeyboardResponse({
                valid_responses: ['space'],
                rt_method: 'date',
                persist: false,
                allow_held_key: false,
                callback_function: (info) => {
                    jsPsych.finishTrial(this.data);
                    this.display.empty();
                    return jsPsych.endCurrentTimeline();
                }
            });
        }

        handleKey(s0, a) {
            var _, s1;
            LOG_DEBUG('handleKey', s0, a);
            if (a === 'simulate') {
                if (this.simulationMode) {
                    return this.endSimulationMode();
                } else {
                    return this.startSimulationMode();
                }
            } else {
                if (!this.simulationMode) {
                    this.allowSimulation = false;
                    if (this.defaultLowerMessage) {
                        //this.lowerMessage.html('<b>Move with the arrow keys.</b>');
                        //this.lowerMessage.css('color', '#000');
                    }
                }
                this.data.actions.push(a);
                this.data.simulationMode.push(this.simulationMode);
                this.data.actionTimes.push(Date.now() - this.initTime);
                [_, s1] = this.graph[s0][a];
                // LOG_DEBUG "#{s0}, #{a} -> #{r}, #{s1}"
                return this.move(s0, a, s1);
            }
        }

        startSimulationMode() {
            this.simulationMode = true;
            this.player.set('top', this.states[this.initial].top - 20).set('left', this.states[this.initial].left);
            this.player.set('opacity', 0.4);
            this.canvas.renderAll();
            this.arrive(this.initial);
            // @centerMessage.html 'Ghost Score: <span id=mouselab-ghost-score/>'
            this.rightMessage.html('Ghost Score: <span id=mouselab-score/>');
            this.resetScore();
            this.drawScore(this.data.score);
            return this.lowerMessage.html("<b>👻 Ghost Mode 👻</b>\n<br>\nPress <code>space</code> to return to your corporeal form.");
        }

        endSimulationMode() {
            this.simulationMode = false;
            this.player.set('top', this.states[this.initial].top).set('left', this.states[this.initial].left);
            this.player.set('opacity', 1);
            this.canvas.renderAll();
            this.arrive(this.initial);
            this.centerMessage.html('');
            this.rightMessage.html(RIGHT_MESSAGE);
            this.resetScore();
            return this.lowerMessage.html(this.defaultLowerMessage);
        }

        getOutcome(s0, a) {
            var r, s1;
            LOG_DEBUG(`getOutcome ${s0}, ${a}`);
            [s1, r] = this.graph[s0][a];
            if (this.stateRewards != null) {
                r = this.stateRewards[s1];
            }
            return [r, s1];
        }

        encodeBelief() {
            var b;
            b = _.values(this.states).map((g) => {
                var lab;
                lab = g.label.text;
                if (lab && lab !== LOADING) {
                    return lab;
                } else {
                    return '_';
                }
            });
            b[0] = 0; // first state is known to be 0
            return b.join(' ');
        }

        getReward(s0, a, s1) {
            if (this.stateRewards != null) {
                return this.stateRewards[s1];
            } else {
                return this.graph[s0][a];
            }
        }

        async move(s0, a, s1) {
            var defaultMessage, nClick, newTop, newLeft, notEnoughClicks, r, s1g;
            defaultMessage = "";

            if (this.freeze) {
                LOG_INFO('freeze!');
                this.arrive(s0, 'repeat');
                return;
            }

            if (this.tutor != null) {
                for (var i in this.states) {
                    if (this.states[i].customStateResponse() != null) {
                        this.arrive(s0, 'repeat');
                        return;
                    }
                }
            }

            nClick = this.data.queries.click.state.target.length;
            notEnoughClicks = (this.special.startsWith('trainClick')) && nClick < 4;
            if (notEnoughClicks) {
                this.displayFeedback('Observe at least four nodes before moving!', false, 4)
                this.arrive(s0, 'repeat');
                return;
            }

            this.prompt.html(defaultMessage);
            if (!this.moved) {
                //await this.showFeedback(this.termAction);
                //await this.showCustomFeedback(-1);

                // aks to confirm moving
                if (this.confirmMessage != null && nClick < 3) {
                    let answer = window.confirm(this.confirmMessage);

                    // ugly workaround for blocking key presses after clicking confirm prompt
                    var e = $.Event('keyup');
                    if (a == 'left') {
                        e.which = 37;
                    } else if (a == 'up') {
                        e.which = 38;
                    } else if (a == 'right') {
                        e.which = 39;
                    }
                    setTimeout(function () {
                        $('#jspsych-target').trigger(e);
                    }, 5);

                    if (!answer) {
                        this.arrive(s0, 'repeat');
                        return;
                    }
                } else if (this.tutor != null && !this.tutor.checkFinished(true)) {
                    return this.arrive(s0, 'repeat');
                }

                //this.defaultLowerMessage = '<b>Move with the arrow keys.</b>';
                this.data.expectedScore = this.data.queries.click.state.target.length * -1;
            }

            this.moved = true;
            r = this.getReward(s0, a, s1);
            LOG_DEBUG(`move ${s0}, ${s1}, ${r}`);
            s1g = this.states[s1];
            this.freeze = true;
            newTop = this.simulationMode ? s1g.top - 20 : s1g.top + TOP_ADJUST;
            newLeft = s1g.left + LEFT_ADJUST;
            return this.player.animate({
                left: newLeft,
                top: newTop
            }, {
                duration: this.moveDelay,
                onChange: this.canvas.renderAll.bind(this.canvas),
                onComplete: () => {
                    if (s1g.revealed) {
                        this.data.expectedRewards += r;
                        this.data.expectedScore += r;
                    }
                    this.data.rewards.push(r);
                    this.addScore(r);
                    this.spendEnergy(this.moveEnergy);
                    return this.arrive(s1);
                }
            });
        }

        async preClickState(g, s) {
            //console.log(`preClickState ${s}`);

            // intercept background clicking
            if (s == -11) {
                if (!this.freeze && this.backgroundRect.customStateResponse() == null) {
                    if (this.show_interactive_flowchart && this.pre_selected != '-') {
                        this.states[this.pre_selected].unhighlight();
                        this.tutor.reset();
                    } else if (this.selected.length > 0) {
                        if (window.confirm('Are you sure you want to reset your answer?')) {
                            this.unhighlightAllNodes();
                            this.selected = [];
                        }
                    }
                }
                return;
            }
            if (this.complete || (`${s}` === `${this.initial}`) || this.freeze) {
                return;
            }
            if (this.moved) {
                this.lowerMessage.html("<b>You can't use the node inspector after moving!</b>");
                this.lowerMessage.css('color', '#FC4754');
                return;
            }
            if (g.customStateResponse() != null) {
                return;
            }
            if (this.show_interactive_instructions && this.tutor.checkFinished()) {
                mdp.displayFeedback('Please start moving!', true, 2);
                return;
            }

            if (this.stateLabels && this.stateDisplay === 'click' && !g.highlighted) {
                if (this.show_interactive_flowchart) {
                    if (this.pre_selected != '-') this.states[this.pre_selected].unhighlight(); //reset selection

                    // new pre selcted
                    g.highlight('red');
                    this.tutor.reset();
                    this.pre_selected = parseInt(s);
                    this.recordQuery('preselect', 'state', this.pre_selected);
                    this.recordQuery('preselect', 'clickable', this.tutor.checkState(this.pre_selected));

                    this.tutor.click('right');

                    if (this.tutor.force_interaction) {
                        fabric.Object.prototype.hoverCursor = 'default';
                        this.freeze = true;
                    }

                } else {
                    // --> add to preselect
                    g.highlight('orange');
                    this.selected.push(parseInt(s));
                }
                return this.canvas.renderAll();
            }
            if (this.stateLabels && this.stateDisplay === 'click' && g.highlighted && !g.revealed) {
                // --> unselected
                if (this.show_interactive_flowchart) {
                    g.highlight('orange');
                    this.selected.push(parseInt(s));
                    this.tutor.reset();
                } else {
                    g.unhighlight();
                    this.selected.splice(this.selected.indexOf(parseInt(s)), 1);
                }
                return this.canvas.renderAll();
            }
            if (this.stateLabels && this.stateDisplay === 'click' && g.highlighted && g.revealed) {
                if (this.show_interactive_flowchart) {
                    g.highlight('orange');
                    this.selected.push(parseInt(s));
                    this.tutor.reset();
                } else {
                    g.unhighlight();
                    this.selected.splice(this.selected.indexOf(parseInt(s)), 1);
                }
                return;
            }
        }

        auto_select() {
            this.unhighlightAllNodes();

            let allowed_to_click = []
            for (var i in this.states) {
                let s = parseInt(this.states[i].name);
                if (this.tutor != null && s != 0 && this.tutor.checkState(s)) allowed_to_click.push(s);
            }
            let selected = allowed_to_click[Math.floor(Math.random() * allowed_to_click.length)];
            this.clickState(this.states[selected], selected);
            this.selected = [];
        }

        async clickState(g, s) {
            var r;
            LOG_INFO(`clickState ${s}`);
            if (this.moved) {
                this.lowerMessage.html("<b>You can't use the node inspector after moving!</b>");
                this.lowerMessage.css('color', '#FC4754');
                return;
            }
            if (this.complete || (`${s}` === `${this.initial}`) || this.freeze) {
                return;
            }
            if (this.special === 'trainClickBlock' && this.data.queries.click.state.target.length === 2) {
                this.lowerMessage.html('<b>Nice job! You can click on more nodes or start moving.</b>');
                this.lowerMessage.css('color', '#000');
            }
            if (this.show_interactive_instructions && this.tutor.checkFinished()) {
                mdp.displayFeedback('Please start moving!', true, 2);
                return;
            }

            if (this.stateLabels && this.stateDisplay === 'click' && !g.revealed) {
                //g.setLabel(LOADING);
                this.addScore(-this.stateClickCost);
                //await this.showFeedback(s); // Note: this must be called before g.setLabel r
                //this.showCustomFeedback(s);
                this.recordQuery('click', 'state', s);
                if (this.tutor) this.recordQuery('click', 'clickable', this.tutor.checkState(s));

                this.spendEnergy(this.clickEnergy);
                r = this.stateLabels[s];
                g.reveal(r);

                if (this.tutor != null && this.tutor.auto_instruct) this.tutor.auto_expand();

                return this.canvas.renderAll();
            }
        }

        findTermNodes(s) {
            var s = parseInt(s);
            var term_nodes = [];
            var av_actions = removePrivate(this.graph)[s];

            if (Object.keys(av_actions).length == 0) {
                term_nodes = [s];
            } else {
                for (var a in av_actions) {
                    var next_node = av_actions[a][1];
                    term_nodes = term_nodes.concat(this.findTermNodes(next_node));
                }
            }
            return term_nodes;
        }

        updateNotes(s) {
            if (this.show_path_rewards) {
                var s = parseInt(s);
                let term_nodes = this.findTermNodes(s);
                let r = this.stateRewards[s];

                for (let i in term_nodes) {
                    let note = this.notes[term_nodes[i]];
                    note.setLabel(parseInt(note.label.text) + r);
                }
            }
        }

        unhighlightAllNodes() {
            for (var i in this.states) {
                if (i != 0) {
                    this.states[i].unhighlight();
                }
            }
        }

        async displayFeedback(feedback, positive, duration = 4) {
            this.lowerMessage.html("<div id='feedback' style='font-weight:bold; font-size:16pt'/>");
            $('#feedback').html(feedback);
            positive ? $('#feedback').css('color', '#080') : $('#feedback').css('color', 'red');

            var self = this;
            clearInterval(this.feedback_timeout);
            this.feedback_timeout = setTimeout(function () {
                self.lowerMessage.html(self.defaultLowerMessage);
            }, duration * 1000);
        }

        // shows positve feedback for clicking leaves else negative
        // called after first move (-1) and after each click (s)
        async showCustomFeedback(action) {
            if (this.show_custom_feedback) {
                //console.log('showCustomFeedback');

                // prepare feedback
                var correct_actions = [3, 4, 7, 8, 11, 12];
                var delay = 1;
                var a = parseInt(action);
                this.freeze = true;
                this.lowerMessage.html("<div id='feedback' style='color:#FF0000; font-weight:bold; font-size:18pt'/>");

                // after taking first move
                if (a == -1) {
                    delay = 2;

                    // check if all leaves were uncovered after
                    if (this.num_clicked_leaves == correct_actions.length) {
                        $('#feedback').html("Good move!");
                        $('#feedback').css('color', '#080');
                    } else {
                        $('#feedback').html("Bad, there were still good clicks to perform!");
                        $('#feedback').css('color', 'red');
                    }
                    await sleep(delay * 1000);

                } // after clicking
                else {

                    // set feedback
                    if (correct_actions.includes(a)) {
                        $('#feedback').html("Good!");
                        $('#feedback').css('color', '#080');
                        this.num_clicked_leaves++;
                    } else {
                        $('#feedback').html("Bad!");
                        $('#feedback').css('color', 'red');
                    }
                    await sleep(delay * 1000);
                }

                // terminate feedback
                this.clearFeedback();
            }
            return this.freeze = false;
        }


        async showFeedback(action) {
            var a, delay, highlight, i, info_feedback, len, loss, optimal, q, qs, ref, strictness, v;
            //console.log('showFeedback');
            // @clearFeedback()
            this.freeze = true;
            if (!this.show_feedback) {
                if (action !== this.termAction) {
                    await sleep(this.clickDelay);
                }
                //f this.freeze = false;
                return;
            }
            qs = this.qs[this.encodeBelief()];
            v = _.max(qs);
            optimal = (function () {
                var results;
                results = [];
                for (a in qs) {
                    q = qs[a];
                    if (v - q < .01) {
                        results.push(a);
                    }
                }
                return results;
            })();
            strictness = 1;
            loss = v - qs[action];
            if (loss > 0) {
                delay = 2 + Math.round(strictness * loss);
            } else {
                delay = 0;
            }
            this.lowerMessage.html("<div id='feedback' style='color:#FF0000; font-weight:bold; font-size:18pt'/>");
            highlight = false;
            info_feedback = with_info && loss > 0;
            if (info_feedback) {
                if (ref = this.termAction, indexOf.call(optimal, ref) >= 0) {
                    // $('#feedback').append """
                    //   An expert player would have stopped clicking and started moving.
                    // """
                    this.prompt.prepend("<img src=static/images/arrow.png class='feedback-img'/>");
                } else {
                    // $('#feedback').append """
                    //   An expert player would have inspected one of the highlighted nodes.
                    // """
                    this.prompt.prepend("<img src=static/images/click.png class='feedback-img'/>");
                    highlight = true;
                    for (i = 0, len = optimal.length; i < len; i++) {
                        a = optimal[i];
                        this.states[a].circle.set('fill', '#49f');
                        this.canvas.renderAll();
                    }
                }
            }
            if (with_reward) {
                if (delay < 1) {
                    $('#feedback').html("Good job!");
                    $('#feedback').css('color', '#080');
                } else {
                    $('#feedback').html(`Delay penalty for poor planning: ${delay} seconds.`);
                    this.data.delays.push(delay);
                    await sleep(delay * 1000);
                }
            }
            if (!(action === this.termAction && delay < 1)) {
                await sleep(this.clickDelay);
            }
            this.clearFeedback();
            return this.freeze = false;
        }

        clearFeedback() {
            var g, ref, s;
            ref = this.states;
            for (s in ref) {
                g = ref[s];
                g.circle.set('fill', '#bbb');
            }
            this.canvas.renderAll();
            this.prompt.html("");
            return this.lowerMessage.html(this.defaultLowerMessage);
        }

        mouseoverState(g, s) {
            // LOG_DEBUG "mouseoverState #{s}"
            if (this.stateLabels && this.stateDisplay === 'hover') {
                // webppl.run('flip()', (s, x) -> g.setLabel (Number x))
                g.setLabel(this.stateLabels[s]);
                return this.recordQuery('mouseover', 'state', s);
            }
        }

        mouseoutState(g, s) {
            // LOG_DEBUG "mouseoutState #{s}"
            if (this.stateLabels && this.stateDisplay === 'hover') {
                g.setLabel('');
                return this.recordQuery('mouseout', 'state', s);
            }
        }

        clickEdge(g, s0, r, s1) {
            var ref;
            if (!this.complete && g.label.text === '?') {
                LOG_DEBUG(`clickEdge ${s0} ${r} ${s1}`);
                if (this.edgeLabels && this.edgeDisplay === 'click' && ((ref = g.label.text) === '?' || ref === '')) {
                    g.setLabel(this.getEdgeLabel(s0, r, s1));
                    return this.recordQuery('click', 'edge', `${s0}__${s1}`);
                }
            }
        }

        mouseoverEdge(g, s0, r, s1) {
            // LOG_DEBUG "mouseoverEdge #{s0} #{r} #{s1}"
            if (this.edgeLabels && this.edgeDisplay === 'hover') {
                g.setLabel(this.getEdgeLabel(s0, r, s1));
                return this.recordQuery('mouseover', 'edge', `${s0}__${s1}`);
            }
        }

        mouseoutEdge(g, s0, r, s1) {
            // LOG_DEBUG "mouseoutEdge #{s0} #{r} #{s1}"
            if (this.edgeLabels && this.edgeDisplay === 'hover') {
                g.setLabel('');
                return this.recordQuery('mouseout', 'edge', `${s0}__${s1}`);
            }
        }

        getEdgeLabel(s0, r, s1) {
            if (this.edgeLabels === 'reward') {
                return '®';
            } else {
                return this.edgeLabels[`${s0}__${s1}`];
            }
        }

        recordQuery(queryType, targetType, target, time = null) {
            this.canvas.renderAll();
            // LOG_DEBUG "recordQuery #{queryType} #{targetType} #{target}"
            // @data["#{queryType}_#{targetType}_#{target}"]
            this.data.queries[queryType][targetType].target.push(target);
            time = (time == null) ? time = Date.now() - this.initTime : time;
            this.data.queries[queryType][targetType].time.push(time);
        }

        arrive(s, repeat = false) {
            var a, g, keys;
            g = this.states[s];
            g.reveal(this.stateRewards[s]);
            this.canvas.renderAll();
            LOG_DEBUG('arrive', s);
            if (!repeat) { // not sending back to previous state
                this.data.path.push(s);
                this.freeze = false;
            }
            // Get available actions.
            if (this.graph[s]) {
                keys = (function () {
                    var i, len, ref, results;
                    ref = Object.keys(this.graph[s]);
                    results = [];
                    for (i = 0, len = ref.length; i < len; i++) {
                        a = ref[i];
                        results.push(this.keys[a]);
                    }
                    return results;
                }).call(this);
            } else {
                keys = [];
            }
            if (this.allowSimulation) {
                keys.push('space');
            }
            if (!keys.length) {
                this.complete = true;
                this.checkFinished();
                return;
            }

            //f
            var all_keys = [40, 37, 38, 39];

            if (!mdp.showParticipant) {
                // Start key listener.
                return this.keyListener = jsPsych.pluginAPI.getKeyboardResponse({
                    valid_responses: all_keys,
                    rt_method: 'date',
                    persist: false,
                    allow_held_key: false,
                    callback_function: (info) => {
                        var action;
                        action = this.invKeys[info.key];
                        if (keys.includes(info.key) && !this.freeze) {
                            // valid key pressed
                            //console.log("valid");
                            LOG_DEBUG('key', info.key);
                            this.data.rt.push(info.rt);
                            return this.handleKey(s, action);

                        }

                        let message = this.freeze ? 'Please, click START to proceed.' : 'Invalid Direction'

                        this.displayFeedback(message, false, 1);
                        return this.arrive(s, true);
                    }
                });
            }
        }

        addScore(v) {
            var score;
            this.data.score += v;
            if (this.simulationMode) {
                score = this.data.score;
            } else {
                SCORE += v;
                score = SCORE;
            }
            return this.drawScore(score);
        }

        resetScore() {
            this.data.score = 0;
            return this.drawScore(SCORE);
        }

        drawScore(score) {
            $('#mouselab-score').html('$' + score);
            return $('#mouselab-score').css('color', redGreen(score));
        }

        spendEnergy(v) {
            this._block.energyLeft -= v;
            if (this._block.energyLeft <= 0) {
                LOG_INFO('OUT OF ENERGY');
                this._block.energyLeft = 0;
                this.freeze = true;
                this.lowerMessage.html("<b>You're out of energy! Press</b> <code>space</code> <b>to continue.</br>");
                this.endBlock();
            }
            return $('#mouselab-energy').html(this._block.energyLeft);
        }

        run() {
            // document.body.style.cursor = 'crosshair'
            jsPsych.pluginAPI.cancelAllKeyboardResponses();
            LOG_DEBUG('run');
            this.buildMap();
            if (this.timeLimit || this.minTime) {
                this.startTimer();
            }
            fabric.Image.fromURL(this.playerImage, ((img) => {
                //this.initPlayer(img);
                this.canvas.renderAll();
                this.initTime = Date.now();
                this.arrive(this.initial);
                if (this.show_interactive_instructions) {
                    this.freeze = true;
                }
            }));
            if (this.showParticipant) {
                return this.runDemo();
            }
        }

        draw(obj) {
            this.canvas.add(obj);
            return obj;
        }

        initPlayer(img) {
            var left, top;
            LOG_DEBUG('initPlayer');
            top = this.states[this.initial].top + TOP_ADJUST;
            left = this.states[this.initial].left + LEFT_ADJUST;
            img.scale(0.35);
            img.rotate(180);
            img.set('top', top).set('left', left);
            this.draw(img);
            return this.player = img;
        }

        buildMap() {
            var a, actions, height, location, maxx, maxy, minx, miny, r, ref, ref1, ref2, results, s, s0, s1, width, x,
                xs, xs2, y, ys, ys2, f;
            // Resize canvas.
            [xs, ys] = _.unzip(_.values(this.layout));

            minx = _.min(xs);
            miny = _.min(ys);
            maxx = _.max(xs);
            maxy = _.max(ys);
            [width, height] = [maxx - minx + 1, maxy - miny + 1.5];
            this.canvasElement.attr({
                width: width * SIZE,
                height: height * SIZE
            });
            this.canvas = new fabric.Canvas('mouselab-canvas', {
                selection: false
            });
            fabric.Object.prototype.hoverCursor = 'pointer';

            // add background object to detect clciking
            if (this.show_pre_select) {
                var rect = new fabric.Rect({
                    left: 0,
                    top: 0,
                    width: this.canvas.getWidth() * SIZE,
                    height: this.canvas.getHeight() * SIZE,
                    fill: 'grey',
                    opacity: 0,
                });
                rect.on('mousedown', () => {
                    this.preClickState(-11, -11);
                });
                this.canvas.add(rect);
                this.backgroundRect = {
                    'object': rect, 'customStateResponse': (function () {
                        return null;
                    })
                }
            }

            this.states = {};
            ref = removePrivate(this.layout);
            for (s in ref) {
                location = ref[s];
                [x, y] = location;
                //console.log('MAAAAAP');
                //console.log(x);
                //console.log(y);
                if (x == 0 && y == 0) {
                    f = '#000000';
                } else {
                    f = '#bbb';
                }
                this.states[s] = new State(s, x - minx, y - miny, {
                    fill: f,
                    label: this.stateDisplay === 'always' ? this.stateLabels[s] : ''
                });
            }
            ref1 = removePrivate(this.graph);
            results = [];
            for (s0 in ref1) {
                actions = ref1[s0];
                results.push((function () {
                    var results1;
                    results1 = [];
                    for (a in actions) {
                        [r, s1] = actions[a];
                        results1.push(new Edge(this.states[s0], r, this.states[s1], {
                            label: this.edgeDisplay === 'always' ? this.getEdgeLabel(s0, r, s1) : ''
                        }));
                    }
                    return results1;
                }).call(this));
            }

            //unlock predefined
            //MATEO
            if (this.revealed != null) {
                for (let s of this.revealed) {
                    this.recordQuery('click', 'state', s);
                    this.states[parseInt(s)].reveal(this.stateLabels[s]);
                }
            }

            return results;
        }

        async endTrial() {
            window.clearInterval(this.timerID);
            clearInterval(this.feedback_timeout);
            if (this.blockOver) {
                return;
            }
            //f
            if (this.showMoneyMade) {
                clearInterval(this.feedback_timeout);
                this.lowerMessage.html("<b>The monkey made <span class=mouselab-score/> on this round. </b> <br><span id=wait/>");
                $('.mouselab-score').html('$' + this.data.score);
                $('.mouselab-score').css('color', redGreen(this.data.score));
                $('.mouselab-score').css('font-weight', 'bold');
            } else {
                this.lowerMessage.html("<span id=wait/>");
            }
            //console.log(this.postTrialDelay);
            if (this.postTrialDelay) {
                $('#wait').html("Preparing next trial...");
                await sleep(this.postTrialDelay * 1000);
            }
            $('#wait').html("<b>Press</b> <code>space</code> <b>to continue.</b>");
            this.defaultLowerMessage = "<b>Press</b> <code>space</code> <b>to continue.</b>";
            // @lowerMessage.html """You made <span class=mouselab-score/> on this round."""
            // await sleep 1000
            // @lowerMessage.append "<br><b>Press</b> <code>space</code> <b>to continue.</b>"
            return this.keyListener = jsPsych.pluginAPI.getKeyboardResponse({
                valid_responses: ['space'],
                rt_method: 'date',
                persist: false,
                allow_held_key: false,
                callback_function: (info) => {
                    this.data.trialTime = getTime() - this.initTime;
                    jsPsych.finishTrial(this.data);
                    return this.stage.empty();
                }
            });
        }

        checkFinished() {
            if (this.complete) {
                if (this.timeLeft != null) {
                    if (this.timeLeft > 1) {
                        return this.waitMessage.show();
                    } else {
                        this.waitMessage.hide();
                        return this.endTrial();
                    }
                } else {
                    return this.endTrial();
                }
            }
        }

    };

    //  =========================== #
    //  ========= Tutors ========= #
    //  =========================== #
    Tutor = class Tutor {

        constructor(container, config) {
            //parameter
            var conf = {
                name: 'Tutor',
                force_correct: false,
                show_feedback: false,
                force_correct_clicking: false,
                force_click_all_correct_nodes: false,
            }
            _.extend(conf, config);

            this.name = conf.name;
            this.container = container;
            this.force_correct = conf.force_correct;
            this.show_feedback = conf.show_feedback;
            this.force_correct_clicking = conf.force_correct_clicking;
            this.force_click_all_correct_nodes = conf.force_click_all_correct_nodes;

            //custom note:
            $('<div>', {
                id: 'mouselab-flowchart-note-upper',
                html: "<p class='intro'>Select ALL nodes that the following " + this.name + " allows you to click:</p>",
            }).appendTo(this.container);

            // ----------------- predicates and helper
            this.pred = {
                'onLevel': null,
                'onBestPath': null,
                'isUnobserved': null,
                'onItsPathIs': null,
                'onItsBestPathIs': null
            };
            this.helper = {
                'getLevel': null,
                'getPathNodes': null,
                'getNodeValues': null,
                'getBestPathTerms': null,
                'getPathValueByTerm': null
            };

            this.pred.onLevel = function (s, neg, level) {
                let answer = this.helper.getLevel(s) == level;
                let text = 'lies on level ' + String(this.helper.getLevel(s));

                return {'answer': this.helper.getNegate(answer, neg), 'text': text, 'beginning': false};
            };

            this.pred.onBestPath = function (s, neg) {
                let best_path_terms = this.helper.getBestPathTerms.call(null, s);
                let node_terms = mdp.findTermNodes(s);
                let intersection = node_terms.filter(value => -1 !== best_path_terms.indexOf(value));
                let answer = intersection.length > 0;
                let pv = this.helper.getPathValueByTerm;
                let text = '';

                if (answer) {
                    text = 'lies on a best path with value ' + pv(intersection[0]);
                } else {
                    text = "lies on a path with value " + Math.max(pv(node_terms[0]), pv(node_terms[node_terms.length - 1]));
                    text += (best_path_terms.length == 1) ? ' whereas the best path has value ' : ' whereas the best paths have value '
                    text += pv(best_path_terms[0]);
                }
                //let text = answer ? 'lies on a best path with value ' + this.getPathValueByTerm(intersection[0]) : "lies on a pth with value " + max(this.getPathValueByTerm);

                //  : "doesn't lie on a best path";
                return {'answer': this.helper.getNegate(answer, neg), 'text': text, 'beginning': false};
            }

            this.pred.isUnobserved = function (s, neg, value) {
                let answer = !mdp.states[String(s)].revealed;
                let text = answer ? 'it is an unobserved node' : "it is an observed node";

                return {'answer': this.helper.getNegate(answer, neg), 'text': text, 'beginning': true};
            }

            this.pred.onItsPathIs = function (s, neg, value) {
                let path_nodes = this.helper.getPathNodes.call(null, s);
                let path_values = this.helper.getNodeValues.call(null, path_nodes);
                let answer = path_values.includes(value);
                let text = '';
                if (this.helper.getLevel.call(null, s) < 3) {
                    text = answer ? "there's a path that passes through this node which contains a " + String(value) : "neither of the paths that pass through this node contain a " + String(value);
                } else {
                    text = answer ? "the path that passes through this node contains a " + String(value) : "the path that passes through this node does not contain a " + String(value);
                }

                return {'answer': this.helper.getNegate(answer, neg), 'text': text, 'beginning': false};
            }

            this.pred.onItsBestPathIs = function (s, neg, value) {
                let best_path_terms = this.helper.getBestPathTerms.call(null, s);
                let node_terms = mdp.findTermNodes(s);
                let answer = null;

                //intersection
                best_path_terms = node_terms.filter(value => -1 !== best_path_terms.indexOf(value));

                if (best_path_terms.length == 0) {
                    answer = false;
                } else {
                    // find best path values
                    let best_path_nodes = this.helper.getPathNodes.call(null, best_path_terms[0]);
                    let best_path_values = this.helper.getNodeValues.call(null, best_path_nodes);
                    answer = best_path_values.includes(value);
                }
                let text = answer ? "lies on a best path which pass through a " + String(value) : "lies on a best path which doesn't pass through a " + String(value);

                return {
                    'answer': this.helper.getNegate(answer, neg),
                    'text': text,
                    'beginning': false,
                    'value': String(value)
                };
            }

            this.pred.alwaysFalse = function (s, neg) {
                let answer = false;

                return {'answer': this.helper.getNegate(answer, neg), 'text': '', 'beginning': false};
            };


            this.helper.getNegate = function (answer, neg) {
                return (neg ? !answer : answer);
            }

            this.helper.getLevel = function (s) {
                if ([1, 5, 9].includes(s)) {
                    return 1;
                } else if ([2, 6, 10].includes(s)) {
                    return 2;
                } else {
                    return 3;
                }
            }

            this.helper.getPathNodes = function (s) {
                let path_nodes = [];

                if (s <= 4) {
                    path_nodes = [1, 2];
                } else if (s >= 9) {
                    path_nodes = [9, 10];
                } else {
                    path_nodes = [5, 6]
                }
                path_nodes = path_nodes.concat(mdp.findTermNodes(s));

                return path_nodes
            }

            this.helper.getNodeValues = function (S) {
                let path_values = [];

                for (let s of S) {
                    if (mdp.states[String(s)].revealed) {
                        path_values.push(mdp.stateRewards[s]);
                    }
                }
                return path_values;
            }

            this.helper.getBestPathTerms = function (s) {
                let best_path_terms = [];
                let node_terms = mdp.findTermNodes(s);
                let max = Number.NEGATIVE_INFINITY;

                // find best paths
                for (let key of Object.keys(mdp.notes)) {
                    let n = parseInt(mdp.notes[key].label.text);
                    if (n > max) {
                        best_path_terms = [parseInt(key)];
                        max = n;
                    } else if (n == max) {
                        best_path_terms.push(parseInt(key));
                    }
                }
                return best_path_terms;
            }

            this.helper.getPathValueByTerm = function (term) {
                return mdp.notes[String(term)].label.text;
            }
        }

        checkFinished() {
            for (var i in mdp.states) {
                if (i != 0) {
                    let s = parseInt(mdp.states[i].name);
                    if (this.checkState(s)) return false;
                }
            }
            return true;
        }

        confirm(confirm_button) {
            if (mdp.selected.length == 0) {
                mdp.displayFeedback('Please select at least one node.', false);

            } else {

                confirm_button.hide();

                //store infos
                let gt = [];
                let fp = [];
                let fn = [];
                let tp = [];
                let tn = [];

                for (let i in mdp.states) {
                    let s = parseInt(mdp.states[i].name);
                    if (s != 0) {
                        if (s != 0 && this.checkState(s)) gt.push(parseInt(s));
                        if (mdp.selected.includes(s)) {
                            gt.includes(s) ? tp.push(s) : fp.push(s);
                        } else {
                            gt.includes(s) ? fn.push(s) : tn.push(s);
                        }
                    }
                }

                mdp.data.queries.quiz_selection.answer = mdp.selected;
                mdp.data.queries.quiz_selection.gt = gt;
                mdp.data.queries.quiz_selection.tp = tp;
                mdp.data.queries.quiz_selection.tn = tn;
                mdp.data.queries.quiz_selection.fp = fp;
                mdp.data.queries.quiz_selection.fn = fn;
                mdp.data.queries.quiz_selection.num_tp = tp.length;
                mdp.data.queries.quiz_selection.num_tn = tn.length;
                mdp.data.queries.quiz_selection.num_fp = fp.length;
                mdp.data.queries.quiz_selection.num_fn = fn.length;

                //mdp.data.queries.click.num_tp = correct.length()
                mdp.freeze = true;
                mdp.endTrial();
            }
        }

        recordQuery(targetType, target) {
            this.data[targetType].target.push(target);
            return this.data[targetType].time.push(Date.now() - mdp.initTime);
        }

    };

    Flowchart = class Flowchart extends Tutor {
        constructor(container, config = {}) {

            console.log(config);
            //parameter
            var conf = {
                name: 'flowchart',
                force_correct: false,
                show_feedback: false,
                force_correct_clicking: false,
                force_click_all_correct_nodes: false,

                //custom
                as_quiz: false,
                quiz_random: false,
                quiz_random_N: 3,

                as_auto_select: false,
                auto_select_N: 3,

                force_interaction: false,

                images: [],
                path: '',
                mappings: [],
                offsets: [],
                checks: [],
            }
            _.extend(conf, config);

            //construction
            super(container, conf);

            // config variables
            this.as_quiz = conf.as_quiz;
            this.quiz_random = conf.quiz_random;
            this.quiz_random_N = conf.quiz_random_N;
            this.as_auto_select = conf.as_auto_select;
            this.auto_select_N = conf.auto_select_N;
            this.force_interaction = conf.force_interaction;
            this.images = conf.images;
            this.path = conf.path;
            this.mappings = conf.mappings;
            this.offsets = conf.offsets;
            this.checks = conf.checks;

            // class variables
            this.index = 0;
            this.level = 1;
            this.parts = [];
            this.trace = [];
            this.top = 40;

            console.log(conf);
            console.log(this.images);
            this.data = {
                index: {
                    'target': [],
                    'time': []
                },
                answer: {
                    'target': [],
                    'time': []
                },
                correct: {
                    'target': [],
                    'time': []
                },
                answer_stats: {
                    'total': Array(this.images.length - 3).fill(0),
                    'correct': Array(this.images.length - 3).fill(0),
                }
            };


            $('<div>', {
                id: 'mouselab-flowchart-note',
                html: "Reminder: If no node in the entire tree is observed, every path is best.",
            }).appendTo(this.container);

            // next button
            this.confirm_button = $('<div>', {
                class: 'mouselab-flowchart-confirm',
                html: '<code>Confirm</code>',
            }).on('mousedown', () => {
                return this.confirm(this.confirm_button);
            }).appendTo(this.container).show();

            // left button
            this.left_button = $('<div>', {
                class: 'mouselab-flowchart-button',
                html: '<code>Yes</code>',
            }).on('mousedown', () => {
                return this.click('left');
            }).appendTo(this.container).hide();

            // right button
            this.right_button = $('<div>', {
                class: 'mouselab-flowchart-button',
                html: '<code>No</code>',
            }).on('mousedown', () => {
                return this.click('right');
            }).appendTo(this.container).hide();

            // init image parts
            for (let index in this.images) {
                let flow_part = $('<img>', {
                    src: this.path + this.images[index],
                    class: 'mouselab-flowchart-part',
                }).appendTo(this.container);

                flow_part.css({left: 125, top: this.top});
                if (index != 0) {
                    flow_part.hide();
                }
                this.parts.push(flow_part);
            }
        }

        //unfolding of flowchart
        expand(index, offset) {
            if (index < this.parts.length) {

                // display new question
                let child = this.parts[index];
                let parent = this.parts[this.index];

                if (this.as_quiz) offset = 0.5;
                let offset_left = parent.position().left + parent.width() * offset - child.width() / 2;
                let offset_top = parent.height() * this.level + this.top;
                child.css({left: offset_left, top: offset_top});

                //buttons
                if (this.mappings[index].length > 0) {
                    this.right_button.css({
                        left: offset_left + child.width() * (1 - this.offsets[index]),
                        top: offset_top + child.height() * 0.52
                    });
                    this.left_button.css({
                        left: offset_left + child.width() * this.offsets[index] - this.left_button.width(),
                        top: offset_top + child.height() * 0.52
                    });
                    this.right_button.show();
                    this.left_button.show();
                } else {
                    // term parts reached
                    this.right_button.hide();
                    this.left_button.hide();

                    if (this.force_correct_clicking) {
                        let fP = (function () {
                            mdp.displayFeedback("Good", true, 2);
                            return null;
                        });

                        if (index == this.images.length - 2) {
                            //click
                            let fN = (function () {
                                return mdp.displayFeedback("You reached a CLICK IT decision, please click the selected node again!", false, 3)
                            });
                            for (var i in mdp.states) {
                                if (i != mdp.pre_selected) {
                                    mdp.states[i].customStateResponse = fN;
                                }
                            }
                            mdp.backgroundRect.customStateResponse = fN;
                            //mdp.states[mdp.pre_selected].customStateResponse = fP;

                        } else {
                            // don't click
                            let fN = (function () {
                                return mdp.displayFeedback("The flowchart tells you NOT TO CLICK the selected node, please click a neutral background around this node!", false, 3)
                            });
                            mdp.states[mdp.pre_selected].customStateResponse = fN;
                            //mdp.backgroundRect.customStateResponse = fP;
                        }
                    }

                    if (this.force_interaction) {
                        fabric.Object.prototype.hoverCursor = 'pointer';
                        mdp.freeze = false;
                    }
                }

                if (false) {
                    console.log(index);
                    console.log(offset_left);
                    console.log(parent.position().left);
                    console.log(parent.width() * offset);
                    console.log(child.width() / 2);
                    console.log('- - - - ');
                }
                child.show();
                this.index = index;
                this.level++;

                if (this.as_quiz) {
                    this.level = 1;
                    parent.hide();
                    if (this.trace.length > 0) this.trace.pop().remove();
                }

                //term node --> click current and slect new one
                if (index > this.images.length - 3 && this.as_auto_select) {
                    mdp.preClickState(mdp.states[mdp.pre_selected], mdp.pre_selected);

                    if (mdp.data.queries.preselect.state.target.length < this.auto_select_N) {
                        setTimeout(function () {
                            mdp.autoPreSelect();
                        }, 100);
                    } else {
                        // end trial
                        this.reset(true);
                        mdp.complete = true;
                        mdp.freeze = true;
                        setTimeout(function () {
                            mdp.endTrial();
                        }, 3000);
                    }
                }
            }
        }

        //button functions
        click(choice) {
            let index = this.index;
            let check = this.check(choice);

            // neglect first unfold
            if (index > 0) {
                this.recordQuery('index', index);
                this.recordQuery('answer', choice == 'left');
                this.recordQuery('correct', check);
                this.data.answer_stats.total[index - 1]++;
                if (check) this.data.answer_stats.correct[index - 1]++;
            }

            //refuse unfolding
            if (!this.force_correct || check) {

                // unfold random node
                if (this.quiz_random) {
                    if (this.data.index.target.length < this.quiz_random_N) {
                        let m = 1000;
                        let new_index_pool = []
                        for (let i = 0; i < this.data.answer_stats.total.length; i++) {
                            if (i != index - 1 && m == this.data.answer_stats.total[i]) {
                                new_index_pool.push(i);
                            } else if (i != index - 1 && m > this.data.answer_stats.total[i]) {
                                new_index_pool = [i];
                                m = this.data.answer_stats.total[i];
                            }
                        }
                        let new_index = new_index_pool[Math.floor((Math.random() * new_index_pool.length))] + 1;
                        return this.expand(new_index, 1 - this.offsets[new_index]);

                    } else {
                        return this.expand(this.images.length - 1, 0.5);
                    }
                }

                // normal flowchart
                if (this.mappings[index].length > 0) {
                    if (choice == 'right') {
                        this.trace.push(this.right_button.clone().html('No').css("cursor", "default").appendTo(mdp.flowchartContainer));
                        return this.expand(this.mappings[index][1], 1 - this.offsets[index]);
                    } else {
                        this.trace.push(this.left_button.clone().html('Yes').css("cursor", "default").appendTo(mdp.flowchartContainer));
                        return this.expand(this.mappings[index][0], this.offsets[index]);
                    }
                }
            }
        }

        // unfold everything and record data
        reset(logging = false) {
            if (this.index > 0) {

                this.parts[0].show();
                for (var i = 1; i < this.parts.length; i++) {
                    this.parts[i].hide();
                }
                for (var i = 0; i < this.trace.length; i++) {
                    this.trace[i].remove();
                }
                this.right_button.hide();
                this.left_button.hide();
                this.index = 0;
                this.level = 1;

                //recording flowchart trial
                mdp.recordQuery('flowchart', 'index', this.data.index.target, this.data.index.time);
                mdp.recordQuery('flowchart', 'answer', this.data.answer.target, this.data.answer.time);
                mdp.recordQuery('flowchart', 'correct', this.data.correct.target, this.data.correct.time);

                // reset queries
                this.data.index.target = [];
                this.data.index.time = [];
                this.data.answer.target = [];
                this.data.answer.time = [];
                this.data.correct.target = [];
                this.data.correct.time = [];

                // reset customStateResponse
                for (var i in mdp.states) {
                    mdp.states[i].customStateResponse = (function () {
                        return null;
                    });
                }
                mdp.backgroundRect.customStateResponse = (function () {
                    return null;
                });
                mdp.pre_selected = '-';
            }
            if (logging) {
                mdp.data.queries.flowchart.answer_stats = this.data.answer_stats;
            }

        }

        // check full flowchart for that state
        checkState(s) {
            let current_question = 1;
            let p = this.pred;

            while (current_question <= this.images.length - 3) {
                let answer = true;
                for (let i in this.checks[current_question]) {
                    let ev = eval(this.checks[current_question][i]);
                    if (!ev.answer) answer = false;
                }
                current_question = parseInt(this.mappings[current_question][+!answer]);
            }
            return current_question == (this.images.length - 2); //click decision ?
        }

        // check current question
        check(choice) {
            if (this.index > 0) {

                let s = mdp.pre_selected;
                let p = this.pred;
                let answer = true;
                let feedback = '';
                let verbose = false;
                choice = choice == 'left';

                if (verbose) {
                    console.log('');
                    console.log('check in progress');
                    console.log(s);
                }

                //console.log( this.checks.call(null,this.index, s) == choice);
                for (let i in this.checks[this.index]) {
                    let ev = eval(this.checks[this.index][i]); //uses s and p variables -> dont delete

                    if (verbose) {
                        console.log(this.checks[this.index][i]);
                        console.log(ev.answer);
                        console.log(ev.text);
                    }

                    if (ev.answer) {
                        if (answer) {
                            //special case:
                            if (i == 2) {
                                feedback += ' on which there is no ' + ev.value;
                            } else if (feedback.beginning) {
                                feedback += ev.text + ' which ';
                            } else {
                                feedback += (i == 0) ? ev.text : ' and ' + ev.text;
                            }
                        }
                    } else {
                        feedback = answer ? ev.text : feedback + ' and ' + ev.text;
                        answer = false;
                    }
                }
                // handle error: this node the path
                if ((feedback.substring(0, 3) == 'the') || feedback.substring(0, 7) == 'neither' || feedback.substring(0, 2) == 'it') {
                    feedback = (answer == choice) ? 'Yes, ' + feedback : 'No, ' + feedback + '.';
                } else {
                    feedback = (answer == choice) ? 'Yes, this node ' + feedback : 'No, this node ' + feedback + '.';
                }

                //display feedback
                if (this.show_feedback) {
                    mdp.displayFeedback(feedback, (answer == choice));
                }

                if (verbose) {
                    console.log('');
                    console.log(answer == choice);
                    console.log('Feedback:');
                    console.log(feedback);
                }

                return (answer == choice);
            }
            return true;
        }
    }

    Instructions = class Instructions extends Tutor {
        constructor(container, config = {}) {

            var conf = {
                name: 'instruction',
                force_correct: false,
                show_feedback: false,
                force_correct_clicking: false,
                force_click_all_correct_nodes: false,

                //custom
                auto_instruct: false,
                unlock_first_instruct: false,

                texts: [],
                checks: []
            }
            _.extend(conf, config);

            //construction
            super(container, conf);

            // config variables
            this.auto_instruct = conf.auto_instruct;
            this.unlock_first_instruct = conf.unlock_first_instruct;
            this.texts = conf.texts;
            this.checks = conf.checks;

            // class variables
            this.index = 0;
            this.parts = [];
            this.top = 40;

            // initial instructions
            let child = $('<div>', {
                html: this.texts[0],
                class: 'mouselab-instructions-part',
            }).appendTo(this.container);
            child.css({top: this.top});
            child.css("font-weight", "500");

            this.top += child.height() + 10;
            this.parts.push(child);

            // next button
            this.next_button = $('<div>', {
                class: 'mouselab-instructions-button',
                html: '<code>Start</code>',
            }).on('mousedown', () => {
                return this.click();
            }).appendTo(this.container).show();
            this.next_button.css({top: this.top + 40});

        }

        expand(index) {
            if (index < this.texts.length - 1) {

                // display new question
                let parent = this.parts[this.parts.length - 1];
                let child = $('<div>', {
                    //html: String(this.parts.length) + '. ' + this.texts[index],
                    html: this.texts[index],
                    class: 'mouselab-instructions-part',
                }).appendTo(this.container);
                child.css({top: this.top});
                child.css("font-weight", "500");
                //this.top = child.height() + 30;

                if (this.unlock_first_instruct) {
                    if (index != 1) parent.hide();
                } else if (parent != 'child') {
                    parent.hide();
                }

                child.show();
                if (this.index != 0) parent.css("font-weight", "lighter");
                if (this.unlock_first_instruct && index == this.texts.length - 1) this.parts[0].css("font-weight", "lighter");

                //buttons
                if (!this.auto_instruct) {
                    this.next_button.show();
                } else {
                    this.next_button.html('<code>Confirm</code>');
                    this.next_button.css({top: this.top + child.height() + 20});
                }

                this.parts.push(child);
                this.index = index;
            } else {
                // end of instructions
                this.parts[this.parts.length - 1].hide();
                this.next_button.hide();
                mdp.endTrial();
            }
        }

        //button functions
        click() {
            if (this.index == 0) {
                mdp.freeze = false;
                this.expand(this.index + 1);
                this.auto_expand();

            } else if (this.index != 0) {
                this.confirm(this.next_button);
            }
        }

        // automatically expands unil the next applicable instruction
        auto_expand() {
            let something_to_click = false;
            let expand = false;
            console.log(this);

            while (this.index < this.checks.length && !something_to_click) {
                for (var i in mdp.states) {
                    let s = parseInt(mdp.states[i].name);
                    if (s != 0 && this.checkState(s)) something_to_click = true;
                }
                if (!something_to_click) {
                    this.index++;
                    expand = true;
                }
            }
            if (expand) this.expand(this.index);
        }

        // check current instruction for that state
        checkState(s) {
            if (this.index != 0) {
                let check = this.checks[this.index - 1];

                if (check.length == 0) {
                    console.log('Empty Check');
                    return false;

                } else if (Array.isArray(check[0])) {
                    // composed check --> loop thorugh OR's in check
                    for (let i in check) {
                        if (this.testCheck(check[i], s)) return true;
                    }
                    return false;

                } else {
                    return this.testCheck(check, s);
                }
            }
        }

        testCheck(check, s) {
            s = parseInt(s);
            let p = this.pred;
            let answer = true;

            for (let i in check) {
                let ev = eval(check[i]);
                if (!ev.answer) answer = false;
            }
            return answer;
        }
    }

    //  =========================== #
    //  ========= Graphics ========= #
    //  =========================== #
    Note = class Note {
        constructor(name, left, top, config = {}) {
            var conf;
            this.name = name;
            left = (left + 0.5) * SIZE;
            top = (top + 0.5) * SIZE;
            this.left = left;
            this.top = top;
            conf = {
                left: left,
                top: top,
                fill: '#dcdcdc',
                height: SIZE / 4,
                width: SIZE / 2,
                label: '',
                rx: SIZE / 10,
                ry: SIZE / 10,
                hoverCursor: 'default',
            };
            _.extend(conf, config);

            this.rect = new fabric.Rect(conf);
            this.left = this.rect.left;
            this.top = this.rect.top;

            mdp.canvas.add(this.rect);

            this.setLabel(config.label);
        }

        setLabel(txt, conf = {}) {
            var post, pre;
            if (this.label != null) {
                mdp.canvas.remove(this.label);
            }
            this.label = new Text('----------', this.left, this.top, {
                fontSize: SIZE / 4.5,
                fill: '#44d',
                hoverCursor: 'default',
            });
            mdp.canvas.add(this.label);
            LOG_DEBUG('setLabel', txt);
            ({pre = '', post = ''} = conf);
            // LOG_DEBUG "setLabel #{txt}"
            if (txt != null) {
                this.label.setText(`${pre}${txt}${post}`);
                this.label.setFill(redGreenNotes(txt));
            } else {
                this.label.setText('');
            }
            return this.labeled = true;
        }

        highlight() {
            return this.circle.set('color', '#49f');
        }

    };

    State = class State {
        constructor(name, left, top, config = {}) {
            var conf;
            this.name = name;
            left = (left + 0.5) * SIZE;
            top = (top + 0.5) * SIZE;
            this.left = left;
            this.top = top;
            conf = {
                left: left,
                top: top,
                fill: '#bbbbbb',
                radius: SIZE / 4,
                label: ''
            };
            _.extend(conf, config);
            // Due to a quirk in Fabric, the maximum width of the label
            // is set when the object is initialized (the call to super).
            // Thus, we must initialize the label with a placeholder, then
            // set it to the proper value afterwards.
            this.circle = new fabric.Circle(conf);
            this.label = {};
            // @label = new Text '----------', left, top,
            //   fontSize: SIZE / 4
            //   fill: '#44d'
            this.radius = this.circle.radius;
            this.left = this.circle.left;
            this.top = this.circle.top;

            //states
            this.labeled = false;
            this.highlighted = false;
            this.revealed = false;

            this.customStateResponse = (function () {
                return null
            });

            mdp.canvas.add(this.circle);
            // @setLabel conf.label
            if (!mdp.showParticipant) {
                this.circle.on('mousedown', () => {
                    if (mdp.show_pre_select) {
                        return mdp.preClickState(this, this.name);
                    } else {
                        return mdp.clickState(this, this.name);
                    }
                });
                this.circle.on('mouseover', () => {
                    return mdp.mouseoverState(this, this.name);
                });
                this.circle.on('mouseout', () => {
                    return mdp.mouseoutState(this, this.name);
                });
            }
        }

        setLabel(txt, conf = {}) {
            var post, pre;
            if (this.label != null) {
                mdp.canvas.remove(this.label);
            }
            this.label = new Text('', this.left, this.top, {
                fontSize: SIZE / 4,
                fill: '#44d'
            });
            mdp.canvas.add(this.label);
            LOG_DEBUG('setLabel', txt);
            ({pre = '', post = ''} = conf);
            // LOG_DEBUG "setLabel #{txt}"
            if (txt != null) {
                this.label.setText(`${pre}${txt}${post}`);
                this.label.setFill(redGreen(txt));
            } else {
                this.label.setText('');
            }
            if (mdp.show_pre_select) {
                this.label.on('mousedown', () => {
                    return mdp.preClickState(this, this.name);
                });
            }

            return this.labeled = true;
        }

        reveal(txt) {
            if (!this.revealed) {
                if (this.name != mdp.initial) {
                    this.unhighlight();
                }
                this.setLabel(txt);
                this.revealed = true;
                mdp.updateNotes(this.name);
            }
        }

        highlight(color) {
            let colors = {'orange': '#FFD700', 'red': '#d26e6e'}
            this.highlighted = true;
            return this.circle.set('fill', colors[color]);
        }

        unhighlight() {
            this.highlighted = false;
            return this.circle.set('fill', '#bbbbbb');
        }

    };
    Edge = class Edge {
        constructor(c1, reward, c2, config = {}) {
            var adjX, adjY, ang, labX, labY, label, rotateLabel, spacing, x1, x2, y1, y2;
            ({spacing = 8, adjX = 0, adjY = 0, rotateLabel = false, label = ''} = config);
            [x1, y1, x2, y2] = [c1.left + adjX, c1.top + adjY, c2.left + adjX, c2.top + adjY];
            this.arrow = new Arrow(x1, y1, x2, y2, c1.radius + spacing, c2.radius + spacing);
            ang = (this.arrow.ang + Math.PI / 2) % (Math.PI * 2);
            if ((0.5 * Math.PI <= ang && ang <= 1.5 * Math.PI)) {
                ang += Math.PI;
            }
            [labX, labY] = polarMove(x1, y1, angle(x1, y1, x2, y2), SIZE * 0.45);
            // See note about placeholder in State.
            this.label = new Text('-', labX, labY, {
                angle: rotateLabel ? ang * 180 / Math.PI : 0,
                fill: redGreen(label),
                fontSize: SIZE / 4,
                textBackgroundColor: 'white'
            });
            this.arrow.on('mousedown', () => {
                return mdp.clickEdge(this, c1.name, reward, c2.name);
            });
            this.arrow.on('mouseover', () => {
                return mdp.mouseoverEdge(this, c1.name, reward, c2.name);
            });
            this.arrow.on('mouseout', () => {
                return mdp.mouseoutEdge(this, c1.name, reward, c2.name);
            });
            this.setLabel(label);
            mdp.canvas.add(this.arrow);
            mdp.canvas.add(this.label);
        }

        setLabel(txt, conf = {}) {
            var post, pre;
            ({pre = '', post = ''} = conf);
            // LOG_DEBUG "setLabel #{txt}"
            if (txt) {
                this.label.setText(`${pre}${txt}${post}`);
                this.label.setFill(redGreen(txt));
            } else {
                this.label.setText('');
            }
            return this.labeled = true;
        }

    };
    Arrow = class Arrow extends fabric.Group {
        constructor(x1, y1, x2, y2, adj1 = 0, adj2 = 0) {
            var ang, centerX, centerY, deltaX, deltaY, dx, dy, line, point;
            ang = angle(x1, y1, x2, y2);
            [x1, y1] = polarMove(x1, y1, ang, adj1);
            [x2, y2] = polarMove(x2, y2, ang, -(adj2 + 7.5));
            line = new fabric.Line([x1, y1, x2, y2], {
                stroke: '#555',
                selectable: false,
                strokeWidth: 3
            });
            centerX = (x1 + x2) / 2;
            centerY = (y1 + y2) / 2;
            deltaX = line.left - centerX;
            deltaY = line.top - centerY;
            dx = x2 - x1;
            dy = y2 - y1;
            point = new fabric.Triangle({
                left: x2 + deltaX,
                top: y2 + deltaY,
                pointType: 'arrow_start',
                angle: ang * 180 / Math.PI,
                width: 10,
                height: 10,
                fill: '#555'
            });
            super([line, point]);
            this.ang = ang;
            this.centerX = centerX;
            this.centerY = centerY;
        }

    };
    Text = class Text extends fabric.Text {
        constructor(txt, left, top, config) {
            var conf;
            txt = String(txt);
            conf = {
                left: left,
                top: top,
                fontFamily: 'helvetica',
                fontSize: SIZE / 8
            };
            _.extend(conf, config);
            super(txt, conf);
        }

    };
    // ================================= #
    // ========= jsPsych stuff ========= #
    // ================================= #
    plugin = {
        trial: function (display_element, trialConfig) {
            var trial;
            // trialConfig = jsPsych.pluginAPI.evaluateFunctionParameters trialConfig, ['_init', 'constructor']
            trialConfig.display = display_element;
            LOG_INFO('trialConfig', trialConfig);
            trial = new MouselabMDP(trialConfig);
            trial.run();
            if (trialConfig._block) {
                trialConfig._block.trialCount += 1;

                if (trialConfig._block.trialCount == trialConfig._block.timeline.length) {
                    trialConfig._block.trialCount = 0;
                }
                //console.log(trialConfig._block.trialCount);
                //console.log(trialConfig._block.timeline.length);

            }
            return TRIAL_INDEX += 1;
        }
    };
    return plugin;
})();

// ---
// generated by js2coffee 2.2.0